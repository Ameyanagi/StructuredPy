[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "",
    "text": "Introduction\nWelcome to StructuredPy, a practical guide to building well-structured Python applications. This book takes a hands-on approach to learning Python through real-world projects, focusing on both functional and object-oriented programming approaches.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#who-this-book-is-for",
    "href": "index.html#who-this-book-is-for",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "Who This Book Is For",
    "text": "Who This Book Is For\nThis book is designed for:\n\nPython beginners who understand basic syntax and want to write better code\nProgrammers transitioning to Python from other languages\nAnyone interested in building practical Python applications",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#what-youll-build",
    "href": "index.html#what-youll-build",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "What You’ll Build",
    "text": "What You’ll Build\nThroughout this book, you’ll work on three main projects:\n\nTime Series Data Analysis\n\nAnalyze sensor data using both functions and classes\nLearn data processing techniques\nVisualize time series data\n\nDevice Communication\n\nBuild a mock serial communication system\nHandle device commands and responses\nManage device state and errors\n\nAPI Development\n\nCreate a FastAPI server\nConnect devices through web APIs\nBuild a complete application\n\n\nEach project is presented twice: first using functions, then using classes. This approach helps you understand when to use each style and how to combine them effectively.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "How to Use This Book",
    "text": "How to Use This Book\n\nProject-Based Learning\nEach chapter focuses on building something practical. We start with a problem, break it down into manageable pieces, and build a solution step by step.\n\n\nCode Examples\nAll code examples are available in the code directory. For each project, you’ll find:\ncode/\n├── timeseries/\n├── device/\n└── api/\n\n\nExercises and Practice\nEach chapter includes: - Hands-on exercises - Code challenges - Suggestions for extending the projects",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "Prerequisites",
    "text": "Prerequisites\nTo get the most out of this book, you should:\n\nKnow basic Python syntax (variables, loops, conditionals)\nHave Python installed on your computer\nBe comfortable using a text editor or IDE\nHave a basic understanding of the command line\n\nIf you need to review Python basics, check the appendix for a quick reference.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "Getting Started",
    "text": "Getting Started\n\nClone the book’s repository:\ngit clone https://github.com/Ameyanagi/StructuredPy\nInstall the required packages:\npip install -r requirements.txt\nStart with Chapter 1 and follow along with the code examples.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#what-makes-this-book-different",
    "href": "index.html#what-makes-this-book-different",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "What Makes This Book Different",
    "text": "What Makes This Book Different\nInstead of teaching Python concepts in isolation, this book:\n\nShows both functional and object-oriented approaches\nUses real-world examples\nFocuses on writing maintainable code\nDemonstrates practical project organization",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#navigation",
    "href": "index.html#navigation",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "Navigation",
    "text": "Navigation\n\nUse the sidebar to navigate between chapters\nCode examples can be copied directly from the book\nProjects build on each other progressively\n\nLet’s begin by analyzing time series data in Chapter 1!",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThanks to all contributors and reviewers who helped improve this book.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "StructuredPy: Master Python through Objects and Functions",
    "section": "Contributing",
    "text": "Contributing\nFound a mistake or want to improve the book? Visit the GitHub repository to:\n\nReport issues\nSuggest improvements\nContribute content",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "Why This Book Exists\nPython’s flexibility is both a blessing and a curse. While it allows you to solve problems in many ways, it can be challenging to know which approach is best. This book aims to bridge the gap between writing code that just works and writing code that’s clear, maintainable, and scalable.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#our-approach",
    "href": "preface.html#our-approach",
    "title": "Preface",
    "section": "Our Approach",
    "text": "Our Approach\nWe believe in learning by doing. Instead of abstract concepts, we focus on practical projects that you might encounter in real work. Each project is implemented twice:\n\nFirst using functions - Simple, straightforward, and easy to understand\nThen using classes - Organized, maintainable, and scalable\n\nThis dual approach helps you understand: - When to use each style - The trade-offs involved - How to combine approaches effectively",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#book-structure",
    "href": "preface.html#book-structure",
    "title": "Preface",
    "section": "Book Structure",
    "text": "Book Structure\nEach project follows this pattern:\n\nProblem Introduction\n\nWhat we’re building\nWhy it matters\nExpected outcomes\n\nFunctional Solution\n\nStep-by-step implementation\nKey concepts explained\nCode organization\n\nObject-Oriented Solution\n\nConverting to classes\nBenefits and trade-offs\nDesign decisions\n\nPractical Extensions\n\nReal-world considerations\nCommon challenges\nFurther improvements",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#key-principles",
    "href": "preface.html#key-principles",
    "title": "Preface",
    "section": "Key Principles",
    "text": "Key Principles\nThroughout the book, we emphasize:\n\nWriting clear, focused code\nBuilding maintainable solutions\nMaking conscious design decisions\nTesting and error handling\nReal-world applications",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#a-note-on-style",
    "href": "preface.html#a-note-on-style",
    "title": "Preface",
    "section": "A Note on Style",
    "text": "A Note on Style\nThere’s rarely one “right” way to solve a programming problem. We present approaches that are:\n\nClear to understand\nEasy to maintain\nPractical to implement\nWell-tested in real applications",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "preface.html#getting-help",
    "href": "preface.html#getting-help",
    "title": "Preface",
    "section": "Getting Help",
    "text": "Getting Help\nIf you get stuck:\n\nCheck the code in the book’s repository\nReview the chapter’s key concepts\nTry breaking the problem into smaller pieces\nCheck the online resources in the appendix\n\nRemember: Every experienced programmer was once a beginner. Take your time, practice with the examples, and don’t hesitate to experiment with the code.\nLet’s start building better Python applications!",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html",
    "href": "chapters/01-timeseries-functions.html",
    "title": "2  Time Series Analysis with Functions",
    "section": "",
    "text": "2.1 Introduction\nIn this chapter, we’ll analyze time series data from sensors using Python functions. We’ll build a simple series of functions that can:",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#introduction",
    "href": "chapters/01-timeseries-functions.html#introduction",
    "title": "2  Time Series Analysis with Functions",
    "section": "",
    "text": "Load and validate sensor data\nCalculate basic statistics\nFind patterns in the data\nCreate meaningful visualizations",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#project-overview",
    "href": "chapters/01-timeseries-functions.html#project-overview",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.2 Project Overview",
    "text": "2.2 Project Overview\nWe’ll work with temperature sensor data that looks like this:\ntimestamp,temperature,humidity\n2024-01-01 00:00:00,22.5,45\n2024-01-01 00:01:00,22.6,46\n2024-01-01 00:02:00,22.4,45\nThis data represents temperature and humidity readings taken every minute. Our goal is to create functions that help us understand this data.",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#starting-with-basic-functions",
    "href": "chapters/01-timeseries-functions.html#starting-with-basic-functions",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.6 Starting with Basic Functions",
    "text": "2.6 Starting with Basic Functions\nLet’s begin by creating functions to load and check our data:\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\n\ndef load_sensor_data(filepath):\n    \"\"\"\n    Load sensor data from a CSV file.\n    \n    Example:\n        data = load_sensor_data('sensor_data.csv')\n    \"\"\"\n    try:\n        # Read CSV file with pandas\n        data = pd.read_csv(filepath)\n        \n        # Convert timestamp string to datetime\n        data['timestamp'] = pd.to_datetime(data['timestamp'])\n        \n        return data\n    except FileNotFoundError:\n        print(f\"Error: File {filepath} not found\")\n        return None\n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return None\n\ndef check_data_quality(data):\n    \"\"\"\n    Check if data has required columns and valid values.\n    \n    Example:\n        is_valid = check_data_quality(data)\n    \"\"\"\n    # Check required columns\n    required_columns = ['timestamp', 'temperature', 'humidity']\n    has_columns = all(col in data.columns for col in required_columns)\n    \n    if not has_columns:\n        print(\"Error: Missing required columns\")\n        return False\n    \n    # Check for missing values\n    if data.isnull().any().any():\n        print(\"Warning: Data contains missing values\")\n        \n    return True",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#analysis-functions",
    "href": "chapters/01-timeseries-functions.html#analysis-functions",
    "title": "1  Time Series Analysis with Functions",
    "section": "1.6 Analysis Functions",
    "text": "1.6 Analysis Functions\nNow let’s create functions to analyze our data:\ndef calculate_basic_stats(data):\n    \"\"\"\n    Calculate basic statistics for temperature and humidity.\n    \n    Example:\n        stats = calculate_basic_stats(data)\n        print(f\"Average temperature: {stats['temp_mean']:.1f}°C\")\n    \"\"\"\n    stats = {\n        'temp_mean': data['temperature'].mean(),\n        'temp_max': data['temperature'].max(),\n        'temp_min': data['temperature'].min(),\n        'humid_mean': data['humidity'].mean(),\n        'readings_count': len(data)\n    }\n    return stats\n\ndef find_outliers(data, std_threshold=3):\n    \"\"\"\n    Find outlier readings based on standard deviation.\n    \n    Example:\n        outliers = find_outliers(data, std_threshold=2)\n    \"\"\"\n    temp_mean = data['temperature'].mean()\n    temp_std = data['temperature'].std()\n    \n    outliers = data[\n        abs(data['temperature'] - temp_mean) &gt; std_threshold * temp_std\n    ]\n    \n    return outliers",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#visualization-functions",
    "href": "chapters/01-timeseries-functions.html#visualization-functions",
    "title": "1  Time Series Analysis with Functions",
    "section": "1.6 Visualization Functions",
    "text": "1.6 Visualization Functions\nAdding functions to visualize our data:\ndef plot_temperature_trend(data):\n    \"\"\"\n    Create a line plot of temperature over time.\n    \n    Example:\n        plot_temperature_trend(data)\n        plt.show()\n    \"\"\"\n    plt.figure(figsize=(12, 6))\n    plt.plot(data['timestamp'], data['temperature'])\n    plt.title('Temperature Over Time')\n    plt.xlabel('Time')\n    plt.ylabel('Temperature (°C)')\n    plt.grid(True)\n    \ndef plot_daily_pattern(data):\n    \"\"\"\n    Show average temperature pattern by hour of day.\n    \n    Example:\n        plot_daily_pattern(data)\n        plt.show()\n    \"\"\"\n    # Extract hour from timestamp\n    data['hour'] = data['timestamp'].dt.hour\n    \n    # Calculate mean temperature for each hour\n    daily_pattern = data.groupby('hour')['temperature'].mean()\n    \n    plt.figure(figsize=(10, 6))\n    daily_pattern.plot(kind='bar')\n    plt.title('Average Temperature by Hour')\n    plt.xlabel('Hour of Day')\n    plt.ylabel('Average Temperature (°C)')",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#putting-it-all-together",
    "href": "chapters/01-timeseries-functions.html#putting-it-all-together",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.9 Putting It All Together",
    "text": "2.9 Putting It All Together\nLet’s create a function that uses all our analysis tools:\ndef analyze_sensor_data(filepath):\n    \"\"\"\n    Perform complete analysis of sensor data.\n    \n    Example:\n        results = analyze_sensor_data('sensor_data.csv')\n    \"\"\"\n    # Load data\n    data = load_sensor_data(filepath)\n    if data is None:\n        return None\n    \n    # Check data quality\n    if not check_data_quality(data):\n        return None\n    \n    # Perform analysis\n    results = {\n        'statistics': calculate_basic_stats(data),\n        'outliers': find_outliers(data),\n    }\n    \n    # Create visualizations\n    plot_temperature_trend(data)\n    plt.savefig('temperature_trend.png')\n    plt.close()\n    \n    plot_daily_pattern(data)\n    plt.savefig('daily_pattern.png')\n    plt.close()\n    \n    return results",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#using-our-functions",
    "href": "chapters/01-timeseries-functions.html#using-our-functions",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.10 Using Our Functions",
    "text": "2.10 Using Our Functions\nHere’s how to use the functions we created:\n# Load and analyze data\nfilepath = \"sensor_data.csv\"\nresults = analyze_sensor_data(filepath)\n\nif results:\n    # Print statistics\n    stats = results['statistics']\n    print(f\"Data Summary:\")\n    print(f\"- Average temperature: {stats['temp_mean']:.1f}°C\")\n    print(f\"- Temperature range: {stats['temp_min']:.1f}°C to {stats['temp_max']:.1f}°C\")\n    print(f\"- Number of readings: {stats['readings_count']}\")\n    \n    # Report outliers\n    outliers = results['outliers']\n    print(f\"\\nFound {len(outliers)} outlier readings\")",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#benefits-of-functional-approach",
    "href": "chapters/01-timeseries-functions.html#benefits-of-functional-approach",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.11 Benefits of Functional Approach",
    "text": "2.11 Benefits of Functional Approach\nOur functional approach has several advantages:\n\nEach function has a single, clear purpose\nFunctions can be tested independently\nEasy to add new analysis features\nCode is reusable across different projects",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#practice-exercises",
    "href": "chapters/01-timeseries-functions.html#practice-exercises",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.12 Practice Exercises",
    "text": "2.12 Practice Exercises\n\nBasic: Create a function to calculate the temperature change rate between readings.\nIntermediate: Add a function to detect sudden temperature spikes.\nAdvanced: Create a function to identify daily temperature patterns.",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#whats-next",
    "href": "chapters/01-timeseries-functions.html#whats-next",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.13 What’s Next",
    "text": "2.13 What’s Next\nIn the next chapter, we’ll see how to organize this same functionality using classes, which will help us manage more complex analysis requirements.",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#references",
    "href": "chapters/01-timeseries-functions.html#references",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.14 References",
    "text": "2.14 References\nFor more information on time series analysis with Python, see McKinney (2022).\n\n\n\n\n\n\nMcKinney, Wes. 2022. “Time Series Analysis with Python.” Python for Data Analysis.",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html",
    "href": "chapters/02-timeseries-classes.html",
    "title": "2  Time Series Analysis with Classes",
    "section": "",
    "text": "2.1 Introduction\nIn the previous chapter, we used functions to analyze sensor data. Now, we’ll reorganize the same functionality using a class-based approach. This will help us: - Keep related data and functions together - Maintain analysis state - Make the code more reusable - Add more complex features easily",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#creating-our-sensor-data-class",
    "href": "chapters/02-timeseries-classes.html#creating-our-sensor-data-class",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.2 Creating Our Sensor Data Class",
    "text": "2.2 Creating Our Sensor Data Class\nLet’s start by creating a class to handle our sensor data:\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\n\nclass SensorData:\n    def __init__(self, filepath=None):\n        \"\"\"\n        Initialize SensorData object.\n        \n        Example:\n            sensor = SensorData('sensor_data.csv')\n        \"\"\"\n        self.data = None\n        self.stats = None\n        \n        if filepath:\n            self.load_data(filepath)\n    \n    def load_data(self, filepath):\n        \"\"\"Load data from CSV file.\"\"\"\n        try:\n            self.data = pd.read_csv(filepath)\n            self.data['timestamp'] = pd.to_datetime(self.data['timestamp'])\n            return True\n        except FileNotFoundError:\n            print(f\"Error: File {filepath} not found\")\n            return False\n        except Exception as e:\n            print(f\"Error loading data: {e}\")\n            return False\n    \n    def is_valid(self):\n        \"\"\"Check if data is valid.\"\"\"\n        if self.data is None:\n            return False\n            \n        required_columns = ['timestamp', 'temperature', 'humidity']\n        has_columns = all(col in self.data.columns for col in required_columns)\n        \n        if not has_columns:\n            print(\"Error: Missing required columns\")\n            return False\n            \n        if self.data.isnull().any().any():\n            print(\"Warning: Data contains missing values\")\n            \n        return True",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#adding-analysis-methods",
    "href": "chapters/02-timeseries-classes.html#adding-analysis-methods",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.3 Adding Analysis Methods",
    "text": "2.3 Adding Analysis Methods\nNow let’s add methods for data analysis:\n    def calculate_statistics(self):\n        \"\"\"\n        Calculate basic statistics for the sensor data.\n        \n        Example:\n            sensor.calculate_statistics()\n            print(f\"Average temp: {sensor.stats['temp_mean']:.1f}°C\")\n        \"\"\"\n        if not self.is_valid():\n            return None\n            \n        self.stats = {\n            'temp_mean': self.data['temperature'].mean(),\n            'temp_max': self.data['temperature'].max(),\n            'temp_min': self.data['temperature'].min(),\n            'humid_mean': self.data['humidity'].mean(),\n            'readings_count': len(self.data)\n        }\n        return self.stats\n    \n    def find_outliers(self, std_threshold=3):\n        \"\"\"\n        Find outlier readings based on standard deviation.\n        \n        Example:\n            outliers = sensor.find_outliers(std_threshold=2)\n        \"\"\"\n        if not self.is_valid():\n            return None\n            \n        temp_mean = self.data['temperature'].mean()\n        temp_std = self.data['temperature'].std()\n        \n        return self.data[\n            abs(self.data['temperature'] - temp_mean) &gt; std_threshold * temp_std\n        ]",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#adding-visualization-methods",
    "href": "chapters/02-timeseries-classes.html#adding-visualization-methods",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.4 Adding Visualization Methods",
    "text": "2.4 Adding Visualization Methods\nLet’s add methods for creating visualizations:\n    def plot_temperature_trend(self):\n        \"\"\"\n        Plot temperature over time.\n        \n        Example:\n            sensor.plot_temperature_trend()\n            plt.show()\n        \"\"\"\n        if not self.is_valid():\n            return\n            \n        plt.figure(figsize=(12, 6))\n        plt.plot(self.data['timestamp'], self.data['temperature'])\n        plt.title('Temperature Over Time')\n        plt.xlabel('Time')\n        plt.ylabel('Temperature (°C)')\n        plt.grid(True)\n    \n    def plot_daily_pattern(self):\n        \"\"\"\n        Plot average temperature by hour.\n        \n        Example:\n            sensor.plot_daily_pattern()\n            plt.show()\n        \"\"\"\n        if not self.is_valid():\n            return\n            \n        # Extract hour from timestamp\n        self.data['hour'] = self.data['timestamp'].dt.hour\n        \n        # Calculate mean temperature for each hour\n        daily_pattern = self.data.groupby('hour')['temperature'].mean()\n        \n        plt.figure(figsize=(10, 6))\n        daily_pattern.plot(kind='bar')\n        plt.title('Average Temperature by Hour')\n        plt.xlabel('Hour of Day')\n        plt.ylabel('Average Temperature (°C)')",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#using-our-class",
    "href": "chapters/02-timeseries-classes.html#using-our-class",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.5 Using Our Class",
    "text": "2.5 Using Our Class\nHere’s how to use the SensorData class:\n# Create a sensor data object\nsensor = SensorData('sensor_data.csv')\n\n# Calculate statistics\nif sensor.is_valid():\n    stats = sensor.calculate_statistics()\n    print(f\"Data Summary:\")\n    print(f\"- Average temperature: {stats['temp_mean']:.1f}°C\")\n    print(f\"- Temperature range: {stats['temp_min']:.1f}°C \"\n          f\"to {stats['temp_max']:.1f}°C\")\n    \n    # Find outliers\n    outliers = sensor.find_outliers()\n    print(f\"\\nFound {len(outliers)} outlier readings\")\n    \n    # Create plots\n    sensor.plot_temperature_trend()\n    plt.savefig('temperature_trend.png')\n    plt.close()\n    \n    sensor.plot_daily_pattern()\n    plt.savefig('daily_pattern.png')\n    plt.close()",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#extending-the-class",
    "href": "chapters/02-timeseries-classes.html#extending-the-class",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.6 Extending the Class",
    "text": "2.6 Extending the Class\nOne advantage of using classes is how easily we can add new features. Let’s add some advanced analysis capabilities:\n    def calculate_trends(self, window_size='1H'):\n        \"\"\"\n        Calculate moving averages for temperature.\n        \n        Example:\n            trends = sensor.calculate_trends(window_size='30min')\n        \"\"\"\n        if not self.is_valid():\n            return None\n            \n        return self.data.resample(window_size, on='timestamp').mean()\n    \n    def get_temperature_range(self, start_time=None, end_time=None):\n        \"\"\"\n        Get temperature data for a specific time range.\n        \n        Example:\n            range_data = sensor.get_temperature_range('2024-01-01', '2024-01-02')\n        \"\"\"\n        if not self.is_valid():\n            return None\n            \n        mask = True\n        if start_time:\n            mask &= (self.data['timestamp'] &gt;= start_time)\n        if end_time:\n            mask &= (self.data['timestamp'] &lt;= end_time)\n            \n        return self.data[mask]",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#benefits-of-class-based-approach",
    "href": "chapters/02-timeseries-classes.html#benefits-of-class-based-approach",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.7 Benefits of Class-Based Approach",
    "text": "2.7 Benefits of Class-Based Approach\n\nState Management: The class maintains its data and calculated statistics\nData Validation: Validation happens automatically before operations\nEncapsulation: Data and methods are bundled together\nExtensibility: Easy to add new features\nCode Organization: Related functionality is grouped together",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#comparing-approaches",
    "href": "chapters/02-timeseries-classes.html#comparing-approaches",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.8 Comparing Approaches",
    "text": "2.8 Comparing Approaches\nLet’s compare the functional and class-based approaches:\n\n\n\n\n\n\n\n\nAspect\nFunctional\nClass-Based\n\n\n\n\nState Management\nPass data between functions\nMaintained by class\n\n\nCode Organization\nSeparate functions\nGrouped in class\n\n\nReusability\nFunctions can be used independently\nMethods tied to class\n\n\nComplexity\nSimpler, more straightforward\nMore structured, scalable",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#practice-exercises",
    "href": "chapters/02-timeseries-classes.html#practice-exercises",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.9 Practice Exercises",
    "text": "2.9 Practice Exercises\n\nBasic: Add a method to calculate the rate of temperature change\nIntermediate: Add a method to detect temperature patterns\nAdvanced: Create a method to compare multiple time periods",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#whats-next",
    "href": "chapters/02-timeseries-classes.html#whats-next",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.10 What’s Next",
    "text": "2.10 What’s Next\nIn the next chapters, we’ll apply these programming approaches to device communication, where we’ll see how each style handles different challenges.",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/02-timeseries-classes.html#references",
    "href": "chapters/02-timeseries-classes.html#references",
    "title": "2  Time Series Analysis with Classes",
    "section": "2.11 References",
    "text": "2.11 References\nFor more information on object-oriented programming in Python, see Beazley and Jones (2013).\n\n\n\n\n\n\nBeazley, David, and Brian K Jones. 2013. Python Cookbook. O’Reilly Media.",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html",
    "href": "chapters/03-device-functions.html",
    "title": "6  Device Communication with Functions",
    "section": "",
    "text": "6.1 Introduction\nIn this chapter, we’ll build a mock serial communication system that simulates interaction with a scientific instrument. We’ll create functions to: - Send commands to the device - Read responses - Handle errors - Parse data\nThis will help you understand how to communicate with real hardware devices while practicing in a safe, simulated environment.",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#understanding-serial-communication",
    "href": "chapters/03-device-functions.html#understanding-serial-communication",
    "title": "6  Device Communication with Functions",
    "section": "6.2 Understanding Serial Communication",
    "text": "6.2 Understanding Serial Communication\nBefore we start coding, let’s understand basic serial communication:\n\n\n\n\n\nsequenceDiagram\n    participant Computer\n    participant Device\n    Computer-&gt;&gt;Device: Send Command\n    Note right of Device: Process Command\n    Device-&gt;&gt;Computer: Send Response\n    Note left of Computer: Process Response",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#creating-a-mock-serial-device",
    "href": "chapters/03-device-functions.html#creating-a-mock-serial-device",
    "title": "6  Device Communication with Functions",
    "section": "6.3 Creating a Mock Serial Device",
    "text": "6.3 Creating a Mock Serial Device\nFirst, let’s create a mock serial device that simulates real hardware:\nclass MockSerial:\n    \"\"\"A mock serial device that simulates basic device communication.\"\"\"\n    \n    def __init__(self):\n        self.is_open = False\n        self.temperature = 25.0  # Initial temperature\n        self.buffer = \"\"\n        \n    def open(self):\n        \"\"\"Open the serial connection.\"\"\"\n        self.is_open = True\n        \n    def close(self):\n        \"\"\"Close the serial connection.\"\"\"\n        self.is_open = False\n        \n    def write(self, data):\n        \"\"\"Simulate writing data to device.\"\"\"\n        if not self.is_open:\n            raise IOError(\"Port not open\")\n        self.buffer = data.decode('utf-8').strip()\n        \n    def readline(self):\n        \"\"\"Simulate reading response from device.\"\"\"\n        if not self.is_open:\n            raise IOError(\"Port not open\")\n            \n        # Simulate device responses\n        if self.buffer == \"TEMP?\":\n            response = f\"{self.temperature:.1f}\"\n            # Simulate temperature variation\n            self.temperature += (random.random() - 0.5)\n        elif self.buffer == \"ID?\":\n            response = \"MOCK-DEVICE-001\"\n        elif self.buffer.startswith(\"TEMP:\"):\n            try:\n                self.temperature = float(self.buffer.split(\":\")[1])\n                response = \"OK\"\n            except ValueError:\n                response = \"ERROR: Invalid temperature value\"\n        else:\n            response = \"ERROR: Unknown command\"\n            \n        return (response + \"\\n\").encode('utf-8')",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#communication-functions",
    "href": "chapters/03-device-functions.html#communication-functions",
    "title": "6  Device Communication with Functions",
    "section": "6.4 Communication Functions",
    "text": "6.4 Communication Functions\nNow let’s create functions to communicate with our device:\ndef open_connection(port='/dev/ttyUSB0', baudrate=9600):\n    \"\"\"\n    Open a connection to the device.\n    \n    Example:\n        device = open_connection('/dev/ttyUSB0')\n    \"\"\"\n    try:\n        # In real code, we would use: serial.Serial(port, baudrate)\n        device = MockSerial()\n        device.open()\n        return device\n    except Exception as e:\n        print(f\"Error opening connection: {e}\")\n        return None\n\ndef close_connection(device):\n    \"\"\"\n    Safely close the device connection.\n    \n    Example:\n        close_connection(device)\n    \"\"\"\n    try:\n        device.close()\n        return True\n    except Exception as e:\n        print(f\"Error closing connection: {e}\")\n        return False\n\ndef send_command(device, command):\n    \"\"\"\n    Send a command to the device and get response.\n    \n    Example:\n        response = send_command(device, \"TEMP?\")\n    \"\"\"\n    try:\n        # Send command\n        device.write(command.encode('utf-8'))\n        \n        # Read response\n        response = device.readline()\n        return response.decode('utf-8').strip()\n    except Exception as e:\n        print(f\"Error sending command: {e}\")\n        return None",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#data-handling-functions",
    "href": "chapters/03-device-functions.html#data-handling-functions",
    "title": "6  Device Communication with Functions",
    "section": "6.5 Data Handling Functions",
    "text": "6.5 Data Handling Functions\nLet’s add functions to handle specific types of commands and responses:\ndef get_temperature(device):\n    \"\"\"\n    Get current temperature reading.\n    \n    Example:\n        temp = get_temperature(device)\n        print(f\"Temperature: {temp}°C\")\n    \"\"\"\n    response = send_command(device, \"TEMP?\")\n    if response and not response.startswith(\"ERROR\"):\n        try:\n            return float(response)\n        except ValueError:\n            print(\"Error: Invalid temperature format\")\n            return None\n    return None\n\ndef set_temperature(device, temperature):\n    \"\"\"\n    Set target temperature.\n    \n    Example:\n        success = set_temperature(device, 25.0)\n    \"\"\"\n    response = send_command(device, f\"TEMP:{temperature}\")\n    return response == \"OK\"\n\ndef get_device_id(device):\n    \"\"\"\n    Get device identifier.\n    \n    Example:\n        device_id = get_device_id(device)\n    \"\"\"\n    return send_command(device, \"ID?\")",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#error-handling-functions",
    "href": "chapters/03-device-functions.html#error-handling-functions",
    "title": "6  Device Communication with Functions",
    "section": "6.6 Error Handling Functions",
    "text": "6.6 Error Handling Functions\nLet’s add functions to handle common errors:\ndef check_connection(device):\n    \"\"\"\n    Check if device is responding.\n    \n    Example:\n        if check_connection(device):\n            print(\"Device is connected\")\n    \"\"\"\n    if not device or not device.is_open:\n        return False\n    \n    # Try to get device ID as a connection test\n    response = get_device_id(device)\n    return response is not None and not response.startswith(\"ERROR\")\n\ndef handle_error_response(response):\n    \"\"\"\n    Process error responses from device.\n    \n    Example:\n        if response.startswith(\"ERROR\"):\n            error_msg = handle_error_response(response)\n    \"\"\"\n    if not response.startswith(\"ERROR\"):\n        return None\n        \n    error_codes = {\n        \"ERROR: Unknown command\": \"Invalid command sent to device\",\n        \"ERROR: Invalid temperature value\": \"Temperature value out of range\"\n    }\n    \n    return error_codes.get(response, \"Unknown error occurred\")",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#putting-it-all-together",
    "href": "chapters/03-device-functions.html#putting-it-all-together",
    "title": "6  Device Communication with Functions",
    "section": "6.7 Putting It All Together",
    "text": "6.7 Putting It All Together\nHere’s how to use all these functions together:\ndef monitor_temperature(duration_seconds=10, interval=1):\n    \"\"\"\n    Monitor temperature for a specified duration.\n    \n    Example:\n        readings = monitor_temperature(duration_seconds=5)\n    \"\"\"\n    device = open_connection()\n    if not device:\n        return None\n        \n    readings = []\n    start_time = time.time()\n    \n    try:\n        while time.time() - start_time &lt; duration_seconds:\n            temp = get_temperature(device)\n            if temp is not None:\n                readings.append((time.time(), temp))\n            time.sleep(interval)\n    finally:\n        close_connection(device)\n        \n    return readings",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#example-usage",
    "href": "chapters/03-device-functions.html#example-usage",
    "title": "6  Device Communication with Functions",
    "section": "6.8 Example Usage",
    "text": "6.8 Example Usage\nHere’s a complete example of using our functions:\n# Start monitoring\nprint(\"Starting temperature monitoring...\")\nreadings = monitor_temperature(duration_seconds=5)\n\nif readings:\n    print(\"\\nTemperature Readings:\")\n    for timestamp, temp in readings:\n        print(f\"Time: {timestamp:.1f}s, Temperature: {temp:.1f}°C\")\nelse:\n    print(\"Error: Could not collect temperature readings\")",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#benefits-of-functional-approach",
    "href": "chapters/03-device-functions.html#benefits-of-functional-approach",
    "title": "6  Device Communication with Functions",
    "section": "6.9 Benefits of Functional Approach",
    "text": "6.9 Benefits of Functional Approach\n\nEach function has a clear, single responsibility\nEasy to test individual components\nFunctions can be combined flexibly\nSimple error handling at each step",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#practice-exercises",
    "href": "chapters/03-device-functions.html#practice-exercises",
    "title": "6  Device Communication with Functions",
    "section": "6.10 Practice Exercises",
    "text": "6.10 Practice Exercises\n\nBasic: Add a function to calculate average temperature over multiple readings\nIntermediate: Create a function to detect if temperature is stable\nAdvanced: Implement a data logging function that saves readings to a file",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#whats-next",
    "href": "chapters/03-device-functions.html#whats-next",
    "title": "6  Device Communication with Functions",
    "section": "6.11 What’s Next",
    "text": "6.11 What’s Next\nIn the next chapter, we’ll refactor this code into a class-based approach, which will help us manage device state and create a more robust communication interface.",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/03-device-functions.html#references",
    "href": "chapters/03-device-functions.html#references",
    "title": "6  Device Communication with Functions",
    "section": "6.12 References",
    "text": "6.12 References\nFor more information on serial communication in Python, see pySerial Team (2024).\n\n\n\n\n\n\npySerial Team. 2024. “pySerial Documentation.” 2024. https://pythonhosted.org/pyserial/.",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html",
    "href": "chapters/04-device-classes.html",
    "title": "6  Device Communication with Classes",
    "section": "",
    "text": "6.1 Introduction\nIn the previous chapter, we used functions to communicate with our mock device. Now, we’ll reorganize this functionality into a class-based structure. This will help us: - Maintain device state - Organize related commands - Handle errors consistently - Create a cleaner interface",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#basic-device-interface",
    "href": "chapters/04-device-classes.html#basic-device-interface",
    "title": "6  Device Communication with Classes",
    "section": "6.2 Basic Device Interface",
    "text": "6.2 Basic Device Interface\nLet’s start by creating our device interface class:\nimport time\nimport random\nfrom datetime import datetime\n\nclass DeviceInterface:\n    \"\"\"Interface for communicating with scientific instruments.\"\"\"\n    \n    def __init__(self, port='/dev/ttyUSB0', baudrate=9600):\n        \"\"\"Initialize device interface.\"\"\"\n        self.port = port\n        self.baudrate = baudrate\n        self.device = None\n        self.connected = False\n        \n    def connect(self):\n        \"\"\"Establish connection with the device.\"\"\"\n        try:\n            self.device = MockSerial()\n            self.device.open()\n            self.connected = True\n            print(f\"Connected to device on {self.port}\")\n            return True\n        except Exception as e:\n            print(f\"Connection failed: {e}\")\n            self.connected = False\n            return False\n            \n    def disconnect(self):\n        \"\"\"Close device connection.\"\"\"\n        if self.connected:\n            try:\n                self.device.close()\n                self.connected = False\n                print(\"Disconnected from device\")\n                return True\n            except Exception as e:\n                print(f\"Error disconnecting: {e}\")\n                return False\n        return True",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#command-methods",
    "href": "chapters/04-device-classes.html#command-methods",
    "title": "6  Device Communication with Classes",
    "section": "6.3 Command Methods",
    "text": "6.3 Command Methods\nNow let’s add methods for sending commands:\n    def send_command(self, command):\n        \"\"\"Send a command to the device.\"\"\"\n        if not self.connected:\n            print(\"Error: Device not connected\")\n            return None\n            \n        try:\n            self.device.write(command.encode('utf-8'))\n            response = self.device.readline()\n            return response.decode('utf-8').strip()\n        except Exception as e:\n            print(f\"Command error: {e}\")\n            return None\n            \n    def get_temperature(self):\n        \"\"\"Get current temperature reading.\"\"\"\n        response = self.send_command(\"TEMP?\")\n        if response and not response.startswith(\"ERROR\"):\n            try:\n                return float(response)\n            except ValueError:\n                print(\"Error: Invalid temperature format\")\n                return None\n        return None\n        \n    def set_temperature(self, temperature):\n        \"\"\"Set target temperature.\"\"\"\n        response = self.send_command(f\"TEMP:{temperature}\")\n        return response == \"OK\"\n        \n    def get_device_id(self):\n        \"\"\"Get device identifier.\"\"\"\n        return self.send_command(\"ID?\")",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#adding-monitoring-features",
    "href": "chapters/04-device-classes.html#adding-monitoring-features",
    "title": "6  Device Communication with Classes",
    "section": "6.4 Adding Monitoring Features",
    "text": "6.4 Adding Monitoring Features\nLet’s add methods for continuous monitoring:\n    def monitor_temperature(self, duration_seconds=10, interval=1):\n        \"\"\"Monitor temperature for a specified duration.\"\"\"\n        if not self.connected:\n            print(\"Error: Device not connected\")\n            return None\n            \n        readings = []\n        start_time = time.time()\n        \n        try:\n            while time.time() - start_time &lt; duration_seconds:\n                temp = self.get_temperature()\n                if temp is not None:\n                    timestamp = datetime.now()\n                    readings.append((timestamp, temp))\n                time.sleep(interval)\n        except KeyboardInterrupt:\n            print(\"\\nMonitoring stopped by user\")\n        except Exception as e:\n            print(f\"Monitoring error: {e}\")\n            \n        return readings\n        \n    def check_temperature_stability(self, num_readings=5, interval=1):\n        \"\"\"Check if temperature is stable.\"\"\"\n        readings = []\n        for _ in range(num_readings):\n            temp = self.get_temperature()\n            if temp is not None:\n                readings.append(temp)\n            time.sleep(interval)\n            \n        if not readings:\n            return False\n            \n        # Calculate standard deviation\n        mean = sum(readings) / len(readings)\n        variance = sum((x - mean) ** 2 for x in readings) / len(readings)\n        std_dev = variance ** 0.5\n        \n        # Consider stable if standard deviation is less than 0.5 degrees\n        return std_dev &lt; 0.5",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#data-logging",
    "href": "chapters/04-device-classes.html#data-logging",
    "title": "6  Device Communication with Classes",
    "section": "6.5 Data Logging",
    "text": "6.5 Data Logging\nLet’s add methods for logging data:\n    def start_logging(self, filepath, interval=1):\n        \"\"\"Log temperature readings to a file.\"\"\"\n        print(f\"Starting temperature logging to {filepath}\")\n        \n        try:\n            with open(filepath, 'w') as f:\n                f.write(\"timestamp,temperature\\n\")\n                \n                while True:\n                    temp = self.get_temperature()\n                    if temp is not None:\n                        timestamp = datetime.now()\n                        f.write(f\"{timestamp},{temp}\\n\")\n                        f.flush()  # Ensure data is written immediately\n                    time.sleep(interval)\n                    \n        except KeyboardInterrupt:\n            print(\"\\nLogging stopped by user\")\n        except Exception as e:\n            print(f\"Logging error: {e}\")",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#using-the-device-interface",
    "href": "chapters/04-device-classes.html#using-the-device-interface",
    "title": "6  Device Communication with Classes",
    "section": "6.6 Using the Device Interface",
    "text": "6.6 Using the Device Interface\nHere’s how to use our device interface:\n# Create device interface\ndevice = DeviceInterface('/dev/ttyUSB0')\n\n# Connect to device\nif device.connect():\n    try:\n        # Get device info\n        device_id = device.get_device_id()\n        print(f\"Connected to device: {device_id}\")\n        \n        # Monitor temperature\n        print(\"\\nMonitoring temperature...\")\n        readings = device.monitor_temperature(duration_seconds=5)\n        \n        if readings:\n            print(\"\\nTemperature Readings:\")\n            for timestamp, temp in readings:\n                print(f\"Time: {timestamp}, Temperature: {temp:.1f}°C\")\n                \n        # Check stability\n        if device.check_temperature_stability():\n            print(\"\\nTemperature is stable\")\n        else:\n            print(\"\\nTemperature is not stable\")\n            \n    finally:\n        device.disconnect()",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#benefits-of-class-based-approach",
    "href": "chapters/04-device-classes.html#benefits-of-class-based-approach",
    "title": "6  Device Communication with Classes",
    "section": "6.7 Benefits of Class-Based Approach",
    "text": "6.7 Benefits of Class-Based Approach\n\nState Management:\n\nConnection state is tracked automatically\nDevice settings are maintained\nEasier to handle device configuration\n\nOrganized Interface:\n\nRelated methods are grouped together\nConsistent error handling\nCleaner command structure\n\nExtended Functionality:\n\nEasy to add new features\nCan add property decorators for device settings\nBetter support for complex operations",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#comparing-approaches",
    "href": "chapters/04-device-classes.html#comparing-approaches",
    "title": "6  Device Communication with Classes",
    "section": "6.8 Comparing Approaches",
    "text": "6.8 Comparing Approaches\nLet’s compare the functional and class-based approaches:\n\n\n\nFeature\nFunctional\nClass-Based\n\n\n\n\nState Management\nManual\nAutomatic\n\n\nError Handling\nPer-function\nCentralized\n\n\nCode Organization\nSeparate functions\nGrouped methods\n\n\nDevice Settings\nPassed as parameters\nStored in instance\n\n\nExtensibility\nNew functions\nNew methods and properties",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#practice-exercises",
    "href": "chapters/04-device-classes.html#practice-exercises",
    "title": "6  Device Communication with Classes",
    "section": "6.9 Practice Exercises",
    "text": "6.9 Practice Exercises\n\nBasic: Add a method to calculate average temperature over time\nIntermediate: Implement a method for temperature ramping\nAdvanced: Create a method for automated calibration",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#whats-next",
    "href": "chapters/04-device-classes.html#whats-next",
    "title": "6  Device Communication with Classes",
    "section": "6.10 What’s Next",
    "text": "6.10 What’s Next\nIn the next chapters, we’ll build an API server that uses this device interface to provide network access to our instruments.",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/04-device-classes.html#references",
    "href": "chapters/04-device-classes.html#references",
    "title": "6  Device Communication with Classes",
    "section": "6.11 References",
    "text": "6.11 References\nFor more information on object-oriented programming with hardware devices, see Beazley and Jones (2013).\n\n\n\n\n\n\nBeazley, David, and Brian K Jones. 2013. Python Cookbook. O’Reilly Media.",
    "crumbs": [
      "Device Communication",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Device Communication with Classes</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html",
    "href": "chapters/05-api-basics.html",
    "title": "5  Building a Basic API Server",
    "section": "",
    "text": "5.1 Introduction\nIn this chapter, we’ll create a web API that allows remote access to our devices. We’ll use FastAPI to: - Create HTTP endpoints for device control - Handle device connections - Provide real-time data access - Document our API automatically",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#project-setup",
    "href": "chapters/05-api-basics.html#project-setup",
    "title": "5  Building a Basic API Server",
    "section": "5.2 Project Setup",
    "text": "5.2 Project Setup\nFirst, let’s organize our API server code:\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List, Optional\nimport uvicorn\nimport time\n\n# Import our device interface\nfrom device_interface import DeviceInterface\n\n# Create FastAPI app\napp = FastAPI(\n    title=\"Device Control API\",\n    description=\"API for controlling scientific instruments\",\n    version=\"1.0.0\"\n)\n\n# Store device connection\ndevice = DeviceInterface()",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#basic-data-models",
    "href": "chapters/05-api-basics.html#basic-data-models",
    "title": "5  Building a Basic API Server",
    "section": "5.3 Basic Data Models",
    "text": "5.3 Basic Data Models\nLet’s define our data models using Pydantic:\nclass TemperatureReading(BaseModel):\n    timestamp: str\n    temperature: float\n\nclass DeviceStatus(BaseModel):\n    connected: bool\n    device_id: Optional[str] = None\n    current_temperature: Optional[float] = None",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#basic-routes",
    "href": "chapters/05-api-basics.html#basic-routes",
    "title": "5  Building a Basic API Server",
    "section": "5.4 Basic Routes",
    "text": "5.4 Basic Routes\nLet’s create basic endpoints for device control:\n@app.get(\"/status\")\ndef get_status():\n    \"\"\"Get current device status.\"\"\"\n    if not device.connected:\n        return {\"connected\": False}\n        \n    try:\n        return {\n            \"connected\": True,\n            \"device_id\": device.get_device_id(),\n            \"current_temperature\": device.get_temperature()\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.post(\"/connect\")\ndef connect_device():\n    \"\"\"Connect to the device.\"\"\"\n    if device.connected:\n        return {\"message\": \"Already connected\"}\n        \n    if device.connect():\n        return {\"message\": \"Connected successfully\"}\n    else:\n        raise HTTPException(\n            status_code=500, \n            detail=\"Failed to connect to device\"\n        )\n\n@app.post(\"/disconnect\")\ndef disconnect_device():\n    \"\"\"Disconnect from device.\"\"\"\n    if not device.connected:\n        return {\"message\": \"Already disconnected\"}\n        \n    if device.disconnect():\n        return {\"message\": \"Disconnected successfully\"}\n    else:\n        raise HTTPException(\n            status_code=500, \n            detail=\"Failed to disconnect\"\n        )",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#temperature-control-routes",
    "href": "chapters/05-api-basics.html#temperature-control-routes",
    "title": "5  Building a Basic API Server",
    "section": "5.5 Temperature Control Routes",
    "text": "5.5 Temperature Control Routes\nNow let’s add routes for temperature control:\n@app.get(\"/temperature\")\ndef get_current_temperature():\n    \"\"\"Get current temperature reading.\"\"\"\n    if not device.connected:\n        raise HTTPException(\n            status_code=400, \n            detail=\"Device not connected\"\n        )\n        \n    temp = device.get_temperature()\n    if temp is None:\n        raise HTTPException(\n            status_code=500, \n            detail=\"Failed to read temperature\"\n        )\n        \n    return {\n        \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        \"temperature\": temp\n    }\n\n@app.post(\"/temperature/{value}\")\ndef set_temperature(value: float):\n    \"\"\"Set target temperature.\"\"\"\n    if not device.connected:\n        raise HTTPException(\n            status_code=400, \n            detail=\"Device not connected\"\n        )\n        \n    if device.set_temperature(value):\n        return {\"message\": f\"Temperature set to {value}\"}\n    else:\n        raise HTTPException(\n            status_code=500, \n            detail=\"Failed to set temperature\"\n        )",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#monitoring-routes",
    "href": "chapters/05-api-basics.html#monitoring-routes",
    "title": "5  Building a Basic API Server",
    "section": "5.6 Monitoring Routes",
    "text": "5.6 Monitoring Routes\nLet’s add routes for temperature monitoring:\n@app.get(\"/monitor/{duration}\")\ndef monitor_temperature(duration: int):\n    \"\"\"Monitor temperature for specified duration.\"\"\"\n    if not device.connected:\n        raise HTTPException(\n            status_code=400, \n            detail=\"Device not connected\"\n        )\n        \n    readings = device.monitor_temperature(duration_seconds=duration)\n    if readings is None:\n        raise HTTPException(\n            status_code=500, \n            detail=\"Monitoring failed\"\n        )\n        \n    return [\n        {\n            \"timestamp\": str(timestamp),\n            \"temperature\": temp\n        }\n        for timestamp, temp in readings\n    ]\n\n@app.get(\"/stability\")\ndef check_stability():\n    \"\"\"Check if temperature is stable.\"\"\"\n    if not device.connected:\n        raise HTTPException(\n            status_code=400, \n            detail=\"Device not connected\"\n        )\n        \n    is_stable = device.check_temperature_stability()\n    return {\n        \"stable\": is_stable,\n        \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\")\n    }",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#running-the-server",
    "href": "chapters/05-api-basics.html#running-the-server",
    "title": "5  Building a Basic API Server",
    "section": "5.7 Running the Server",
    "text": "5.7 Running the Server\nHere’s how to run our API server:\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000, reload=True)",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#using-the-api",
    "href": "chapters/05-api-basics.html#using-the-api",
    "title": "5  Building a Basic API Server",
    "section": "5.8 Using the API",
    "text": "5.8 Using the API\nHere are some example API calls using curl:\n# Connect to device\ncurl -X POST http://localhost:8000/connect\n\n# Get current temperature\ncurl http://localhost:8000/temperature\n\n# Monitor temperature for 10 seconds\ncurl http://localhost:8000/monitor/10\n\n# Set temperature\ncurl -X POST http://localhost:8000/temperature/25.5\n\n# Check stability\ncurl http://localhost:8000/stability\n\n# Disconnect\ncurl -X POST http://localhost:8000/disconnect",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#api-documentation",
    "href": "chapters/05-api-basics.html#api-documentation",
    "title": "5  Building a Basic API Server",
    "section": "5.9 API Documentation",
    "text": "5.9 API Documentation\nFastAPI automatically generates interactive documentation. Visit: - /docs for Swagger UI - /redoc for ReDoc documentation",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#error-handling",
    "href": "chapters/05-api-basics.html#error-handling",
    "title": "5  Building a Basic API Server",
    "section": "5.10 Error Handling",
    "text": "5.10 Error Handling\nOur API handles common errors: - Device not connected - Invalid commands - Reading errors - Connection issues\nExample error response:\n{\n    \"detail\": \"Device not connected\",\n    \"status_code\": 400\n}",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#benefits-of-fastapi",
    "href": "chapters/05-api-basics.html#benefits-of-fastapi",
    "title": "5  Building a Basic API Server",
    "section": "5.11 Benefits of FastAPI",
    "text": "5.11 Benefits of FastAPI\n\nAutomatic Documentation:\n\nOpenAPI (Swagger) support\nType checking\nInteractive docs\n\nPerformance:\n\nFast execution\nAsync support\nEfficient validation\n\nDeveloper Experience:\n\nClear error messages\nType hints\nEasy to extend",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#practice-exercises",
    "href": "chapters/05-api-basics.html#practice-exercises",
    "title": "5  Building a Basic API Server",
    "section": "5.12 Practice Exercises",
    "text": "5.12 Practice Exercises\n\nBasic: Add an endpoint to get device information\nIntermediate: Implement data logging endpoint\nAdvanced: Add authentication to the API",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#whats-next",
    "href": "chapters/05-api-basics.html#whats-next",
    "title": "5  Building a Basic API Server",
    "section": "5.13 What’s Next",
    "text": "5.13 What’s Next\nIn the next chapter, we’ll enhance our API with: - Authentication - WebSocket support for real-time data - Data persistence - Multiple device management",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/05-api-basics.html#references",
    "href": "chapters/05-api-basics.html#references",
    "title": "5  Building a Basic API Server",
    "section": "5.14 References",
    "text": "5.14 References\nFor more information on FastAPI, see FastAPI Team (2024).\n\n\n\n\n\n\nFastAPI Team. 2024. “FastAPI Documentation.” 2024. https://fastapi.tiangolo.com/.",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Building a Basic API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html",
    "href": "chapters/06-api-complete.html",
    "title": "6  Building a Complete API Server",
    "section": "",
    "text": "6.1 Introduction\nIn this chapter, we’ll enhance our basic API server with features needed for production use: - Authentication - WebSocket support for real-time data - Multiple device management - Data logging and persistence",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#enhanced-project-structure",
    "href": "chapters/06-api-complete.html#enhanced-project-structure",
    "title": "6  Building a Complete API Server",
    "section": "6.2 Enhanced Project Structure",
    "text": "6.2 Enhanced Project Structure\nFirst, let’s organize our enhanced API server:\nfrom fastapi import FastAPI, WebSocket, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom typing import Dict, List, Optional\nimport asyncio\nimport json\nimport time\n\napp = FastAPI(\n    title=\"Advanced Device Control API\",\n    description=\"Production-ready API for device control\",\n    version=\"2.0.0\"\n)",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#device-manager",
    "href": "chapters/06-api-complete.html#device-manager",
    "title": "6  Building a Complete API Server",
    "section": "6.3 Device Manager",
    "text": "6.3 Device Manager\nLet’s create a class to manage multiple devices:\nclass DeviceManager:\n    def __init__(self):\n        \"\"\"Initialize device manager.\"\"\"\n        self.devices: Dict[str, DeviceInterface] = {}\n        \n    def add_device(self, device_id: str, port: str) -&gt; bool:\n        \"\"\"Add a new device.\"\"\"\n        if device_id in self.devices:\n            return False\n            \n        device = DeviceInterface(port)\n        if device.connect():\n            self.devices[device_id] = device\n            return True\n        return False\n        \n    def remove_device(self, device_id: str) -&gt; bool:\n        \"\"\"Remove a device.\"\"\"\n        if device_id not in self.devices:\n            return False\n            \n        device = self.devices[device_id]\n        device.disconnect()\n        del self.devices[device_id]\n        return True\n        \n    def get_device(self, device_id: str) -&gt; Optional[DeviceInterface]:\n        \"\"\"Get device by ID.\"\"\"\n        return self.devices.get(device_id)\n        \n    def get_all_devices(self) -&gt; List[str]:\n        \"\"\"Get list of all device IDs.\"\"\"\n        return list(self.devices.keys())\n\n# Create device manager instance\ndevice_manager = DeviceManager()",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#authentication",
    "href": "chapters/06-api-complete.html#authentication",
    "title": "6  Building a Complete API Server",
    "section": "6.4 Authentication",
    "text": "6.4 Authentication\nLet’s implement basic authentication:\nfrom datetime import datetime, timedelta\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\n# Security configuration\nSECRET_KEY = \"your-secret-key\"  # In production, use environment variable\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nclass User(BaseModel):\n    username: str\n    disabled: Optional[bool] = None\n\nclass UserInDB(User):\n    hashed_password: str\n\n# Demo user database - use real database in production\nusers_db = {\n    \"admin\": {\n        \"username\": \"admin\",\n        \"hashed_password\": pwd_context.hash(\"password\"),\n        \"disabled\": False\n    }\n}\n\ndef authenticate_user(username: str, password: str):\n    \"\"\"Authenticate user.\"\"\"\n    user = get_user(username)\n    if not user or not pwd_context.verify(password, user.hashed_password):\n        return False\n    return user\n\ndef create_access_token(data: dict):\n    \"\"\"Create JWT token.\"\"\"\n    expires = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    data.update({\"exp\": expires})\n    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    \"\"\"Get current user from token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Invalid authentication credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    user = get_user(username)\n    if user is None:\n        raise credentials_exception\n    return user",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#websocket-support",
    "href": "chapters/06-api-complete.html#websocket-support",
    "title": "6  Building a Complete API Server",
    "section": "6.5 WebSocket Support",
    "text": "6.5 WebSocket Support\nLet’s add real-time data streaming:\nclass ConnectionManager:\n    def __init__(self):\n        \"\"\"Initialize connection manager.\"\"\"\n        self.active_connections: Dict[str, List[WebSocket]] = {}\n        \n    async def connect(self, websocket: WebSocket, device_id: str):\n        \"\"\"Connect websocket client.\"\"\"\n        await websocket.accept()\n        if device_id not in self.active_connections:\n            self.active_connections[device_id] = []\n        self.active_connections[device_id].append(websocket)\n        \n    def disconnect(self, websocket: WebSocket, device_id: str):\n        \"\"\"Disconnect websocket client.\"\"\"\n        if device_id in self.active_connections:\n            self.active_connections[device_id].remove(websocket)\n            \n    async def broadcast_temperature(self, device_id: str, data: dict):\n        \"\"\"Broadcast temperature data to all connected clients.\"\"\"\n        if device_id in self.active_connections:\n            for connection in self.active_connections[device_id]:\n                await connection.send_json(data)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{device_id}\")\nasync def websocket_endpoint(websocket: WebSocket, device_id: str):\n    \"\"\"WebSocket endpoint for real-time temperature data.\"\"\"\n    await manager.connect(websocket, device_id)\n    try:\n        while True:\n            device = device_manager.get_device(device_id)\n            if device:\n                temp = device.get_temperature()\n                if temp is not None:\n                    data = {\n                        \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                        \"temperature\": temp\n                    }\n                    await manager.broadcast_temperature(device_id, data)\n            await asyncio.sleep(1)\n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        manager.disconnect(websocket, device_id)",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#enhanced-api-routes",
    "href": "chapters/06-api-complete.html#enhanced-api-routes",
    "title": "6  Building a Complete API Server",
    "section": "6.6 Enhanced API Routes",
    "text": "6.6 Enhanced API Routes\nLet’s update our routes with authentication and multiple device support:\n@app.post(\"/device/{device_id}\")\nasync def add_device(\n    device_id: str, \n    port: str, \n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Add a new device.\"\"\"\n    if device_manager.add_device(device_id, port):\n        return {\"message\": f\"Device {device_id} added successfully\"}\n    raise HTTPException(\n        status_code=400,\n        detail=\"Failed to add device\"\n    )\n\n@app.get(\"/devices\")\nasync def list_devices(current_user: User = Depends(get_current_user)):\n    \"\"\"List all devices.\"\"\"\n    return {\"devices\": device_manager.get_all_devices()}\n\n@app.get(\"/device/{device_id}/temperature\")\nasync def get_device_temperature(\n    device_id: str,\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get temperature from specific device.\"\"\"\n    device = device_manager.get_device(device_id)\n    if not device:\n        raise HTTPException(\n            status_code=404,\n            detail=\"Device not found\"\n        )\n        \n    temp = device.get_temperature()\n    if temp is None:\n        raise HTTPException(\n            status_code=500,\n            detail=\"Failed to read temperature\"\n        )\n        \n    return {\n        \"device_id\": device_id,\n        \"timestamp\": time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        \"temperature\": temp\n    }",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#data-logging",
    "href": "chapters/06-api-complete.html#data-logging",
    "title": "6  Building a Complete API Server",
    "section": "6.7 Data Logging",
    "text": "6.7 Data Logging\nLet’s add data logging functionality:\nimport sqlite3\nfrom datetime import datetime\n\nclass DataLogger:\n    def __init__(self, db_path=\"device_data.db\"):\n        \"\"\"Initialize data logger.\"\"\"\n        self.db_path = db_path\n        self.init_db()\n        \n    def init_db(self):\n        \"\"\"Initialize database.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        c = conn.cursor()\n        c.execute('''\n            CREATE TABLE IF NOT EXISTS temperature_logs\n            (device_id TEXT, timestamp TEXT, temperature REAL)\n        ''')\n        conn.commit()\n        conn.close()\n        \n    def log_temperature(self, device_id: str, temperature: float):\n        \"\"\"Log temperature reading.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        c = conn.cursor()\n        timestamp = datetime.now().isoformat()\n        c.execute(\n            \"INSERT INTO temperature_logs VALUES (?, ?, ?)\",\n            (device_id, timestamp, temperature)\n        )\n        conn.commit()\n        conn.close()\n        \n    def get_device_history(\n        self, \n        device_id: str, \n        limit: int = 100\n    ) -&gt; List[dict]:\n        \"\"\"Get temperature history for device.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        c = conn.cursor()\n        c.execute(\n            \"\"\"\n            SELECT * FROM temperature_logs \n            WHERE device_id = ? \n            ORDER BY timestamp DESC \n            LIMIT ?\n            \"\"\",\n            (device_id, limit)\n        )\n        rows = c.fetchall()\n        conn.close()\n        \n        return [\n            {\n                \"device_id\": row[0],\n                \"timestamp\": row[1],\n                \"temperature\": row[2]\n            }\n            for row in rows\n        ]\n\n# Create data logger instance\ndata_logger = DataLogger()",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#using-the-enhanced-api",
    "href": "chapters/06-api-complete.html#using-the-enhanced-api",
    "title": "6  Building a Complete API Server",
    "section": "6.8 Using the Enhanced API",
    "text": "6.8 Using the Enhanced API\nHere’s how to use the enhanced API:\n# Example client code\nimport requests\nimport websockets\nimport asyncio\nimport json\n\n# Get access token\nresponse = requests.post(\n    \"http://localhost:8000/token\",\n    data={\"username\": \"admin\", \"password\": \"password\"}\n)\ntoken = response.json()[\"access_token\"]\n\n# Add device\nheaders = {\"Authorization\": f\"Bearer {token}\"}\nresponse = requests.post(\n    \"http://localhost:8000/device/dev1\",\n    headers=headers,\n    params={\"port\": \"/dev/ttyUSB0\"}\n)\n\n# WebSocket client for real-time data\nasync def temperature_monitor():\n    uri = \"ws://localhost:8000/ws/dev1\"\n    async with websockets.connect(uri) as websocket:\n        while True:\n            data = await websocket.recv()\n            print(f\"Temperature: {json.loads(data)}\")\n\n# Run WebSocket client\nasyncio.get_event_loop().run_until_complete(temperature_monitor())",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#benefits-of-enhanced-api",
    "href": "chapters/06-api-complete.html#benefits-of-enhanced-api",
    "title": "6  Building a Complete API Server",
    "section": "6.9 Benefits of Enhanced API",
    "text": "6.9 Benefits of Enhanced API\n\nSecurity:\n\nAuthentication\nToken-based access\nProtected endpoints\n\nReal-time Data:\n\nWebSocket support\nEfficient data streaming\nMultiple client support\n\nScalability:\n\nMultiple device management\nData persistence\nConnection management",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#practice-exercises",
    "href": "chapters/06-api-complete.html#practice-exercises",
    "title": "6  Building a Complete API Server",
    "section": "6.10 Practice Exercises",
    "text": "6.10 Practice Exercises\n\nBasic: Add user management endpoints\nIntermediate: Implement device configuration persistence\nAdvanced: Add data export functionality",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#whats-next",
    "href": "chapters/06-api-complete.html#whats-next",
    "title": "6  Building a Complete API Server",
    "section": "6.11 What’s Next",
    "text": "6.11 What’s Next\nYou’ve now built a complete, production-ready API server. Next steps might include: - Adding more security features - Implementing device discovery - Creating a web interface - Adding data analysis features",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "chapters/06-api-complete.html#references",
    "href": "chapters/06-api-complete.html#references",
    "title": "6  Building a Complete API Server",
    "section": "6.12 References",
    "text": "6.12 References\nFor more information on FastAPI features, see FastAPI Team (2024).\n\n\n\n\n\n\nFastAPI Team. 2024. “FastAPI Documentation.” 2024. https://fastapi.tiangolo.com/.",
    "crumbs": [
      "Building APIs",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Building a Complete API Server</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html",
    "href": "appendices/python_basics.html",
    "title": "4  Python Basics",
    "section": "",
    "text": "4.1 Variables and Data Types\nThis appendix covers the fundamental Python concepts you’ll need for this tutorial.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#variables-and-data-types",
    "href": "appendices/python_basics.html#variables-and-data-types",
    "title": "4  Python Basics",
    "section": "",
    "text": "4.1.1 Basic Data Types\n# Numbers\ntemperature = 25.5       # Float\ncount = 10              # Integer\n\n# Strings\nmessage = \"Hello\"       # String\ndevice_id = 'DEV001'    # String (single or double quotes)\n\n# Booleans\nis_connected = True     # Boolean\nis_ready = False       # Boolean\n\n# None (null value)\nresult = None          # None type\n\n\n4.1.2 Lists and Dictionaries\n# Lists (ordered, changeable)\ntemperatures = [25.5, 26.0, 25.8]\ndevices = ['DEV001', 'DEV002', 'DEV003']\n\n# Accessing list elements\nfirst_temp = temperatures[0]     # 25.5\nlast_device = devices[-1]        # 'DEV003'\n\n# Changing list elements\ntemperatures[0] = 26.5\n\n# Adding to lists\ntemperatures.append(26.2)\n\n# Dictionaries (key-value pairs)\ndevice_info = {\n    'id': 'DEV001',\n    'temperature': 25.5,\n    'connected': True\n}\n\n# Accessing dictionary values\ndevice_id = device_info['id']           # 'DEV001'\ntemp = device_info.get('temperature')   # 25.5",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#control-flow",
    "href": "appendices/python_basics.html#control-flow",
    "title": "4  Python Basics",
    "section": "4.2 Control Flow",
    "text": "4.2 Control Flow\n\n4.2.1 If Statements\ntemperature = 25.5\n\nif temperature &gt; 30:\n    print(\"Temperature too high\")\nelif temperature &lt; 20:\n    print(\"Temperature too low\")\nelse:\n    print(\"Temperature normal\")\n\n# Using and/or\nif temperature &gt; 20 and temperature &lt; 30:\n    print(\"Temperature in range\")\n\n# Checking for None\nif result is not None:\n    print(\"Have result\")\n\n\n4.2.2 Loops\n# For loops with lists\nfor temp in temperatures:\n    print(f\"Temperature: {temp}\")\n\n# For loops with range\nfor i in range(5):\n    print(f\"Reading {i}\")\n\n# While loops\ncount = 0\nwhile count &lt; 5:\n    print(f\"Count: {count}\")\n    count += 1\n\n# Breaking loops\nwhile True:\n    temperature = get_temperature()\n    if temperature &gt; 30:\n        break",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#functions",
    "href": "appendices/python_basics.html#functions",
    "title": "4  Python Basics",
    "section": "4.3 Functions",
    "text": "4.3 Functions\n\n4.3.1 Basic Functions\n# Simple function\ndef get_temperature():\n    return 25.5\n\n# Function with parameters\ndef check_temperature(temp, min_temp, max_temp):\n    return min_temp &lt;= temp &lt;= max_temp\n\n# Function with default values\ndef read_sensor(retries=3):\n    for i in range(retries):\n        # Try reading sensor\n        pass\n\n\n4.3.2 Return Values\n# Single return value\ndef calculate_average(values):\n    if not values:\n        return 0\n    return sum(values) / len(values)\n\n# Multiple return values\ndef get_stats(values):\n    minimum = min(values)\n    maximum = max(values)\n    average = sum(values) / len(values)\n    return minimum, maximum, average",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#exception-handling",
    "href": "appendices/python_basics.html#exception-handling",
    "title": "4  Python Basics",
    "section": "4.4 Exception Handling",
    "text": "4.4 Exception Handling\n# Basic try/except\ntry:\n    temperature = get_temperature()\nexcept Exception as e:\n    print(f\"Error: {e}\")\n\n# Multiple exception types\ntry:\n    with open('data.txt') as f:\n        data = f.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\nexcept PermissionError:\n    print(\"Permission denied\")\nexcept Exception as e:\n    print(f\"Unknown error: {e}\")\n\n# Using finally\ntry:\n    device.connect()\n    device.read_data()\nexcept Exception as e:\n    print(f\"Error: {e}\")\nfinally:\n    device.disconnect()  # Always runs",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#string-formatting",
    "href": "appendices/python_basics.html#string-formatting",
    "title": "4  Python Basics",
    "section": "4.5 String Formatting",
    "text": "4.5 String Formatting\n# f-strings (recommended)\ntemp = 25.5\nmessage = f\"Temperature: {temp}°C\"\n\n# Format method\nmessage = \"Temperature: {:.1f}°C\".format(temp)\n\n# String concatenation\nmessage = \"Temperature: \" + str(temp) + \"°C\"",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#file-operations",
    "href": "appendices/python_basics.html#file-operations",
    "title": "4  Python Basics",
    "section": "4.6 File Operations",
    "text": "4.6 File Operations\n# Reading files\nwith open('data.txt', 'r') as file:\n    content = file.read()        # Read entire file\n    lines = file.readlines()     # Read lines into list\n\n# Writing files\nwith open('log.txt', 'w') as file:\n    file.write(\"Temperature log\\n\")\n    file.write(f\"Reading: {temp}\\n\")\n\n# Appending to files\nwith open('log.txt', 'a') as file:\n    file.write(f\"New reading: {temp}\\n\")",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#modules-and-imports",
    "href": "appendices/python_basics.html#modules-and-imports",
    "title": "4  Python Basics",
    "section": "4.7 Modules and Imports",
    "text": "4.7 Modules and Imports\n# Importing entire modules\nimport time\ntime.sleep(1)\n\n# Importing specific items\nfrom datetime import datetime\ncurrent_time = datetime.now()\n\n# Importing with alias\nimport pandas as pd\ndf = pd.DataFrame()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#essential-built-in-functions",
    "href": "appendices/python_basics.html#essential-built-in-functions",
    "title": "4  Python Basics",
    "section": "4.8 Essential Built-in Functions",
    "text": "4.8 Essential Built-in Functions\n# len() - Length of sequences\nlength = len([1, 2, 3])     # 3\n\n# range() - Number sequences\nfor i in range(5):          # 0 to 4\n\n# print() - Output\nprint(f\"Value: {value}\")    # Formatted output\n\n# type() - Get type of object\ndata_type = type(value)     # Get type\n\n# str(), int(), float() - Type conversion\ntext = str(123)             # Convert to string\nnumber = int(\"123\")         # Convert to integer\ndecimal = float(\"12.3\")     # Convert to float",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#list-operations",
    "href": "appendices/python_basics.html#list-operations",
    "title": "4  Python Basics",
    "section": "4.9 List Operations",
    "text": "4.9 List Operations\n# Common list methods\nvalues = [1, 2, 3]\nvalues.append(4)            # Add to end\nvalues.insert(0, 0)         # Insert at position\nvalues.remove(2)            # Remove value\nvalues.pop()               # Remove and return last item\n\n# List slicing\nfirst_two = values[0:2]     # Get first two items\nreversed_list = values[::-1]  # Reverse list\n\n# List comprehension\nsquares = [x**2 for x in range(5)]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#dictionary-operations",
    "href": "appendices/python_basics.html#dictionary-operations",
    "title": "4  Python Basics",
    "section": "4.10 Dictionary Operations",
    "text": "4.10 Dictionary Operations\n# Common dictionary methods\ninfo = {'id': 'DEV001'}\ninfo['temp'] = 25.5        # Add/update key-value\nvalue = info.get('id')     # Safe get with default\ninfo.update({'connected': True})  # Update multiple\n\n# Checking keys\nif 'id' in info:\n    print(\"Has ID\")\n\n# Dictionary comprehension\nsquares = {x: x**2 for x in range(3)}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#common-modules-used-in-this-tutorial",
    "href": "appendices/python_basics.html#common-modules-used-in-this-tutorial",
    "title": "4  Python Basics",
    "section": "4.11 Common Modules Used in This Tutorial",
    "text": "4.11 Common Modules Used in This Tutorial\n# Time and dates\nimport time\ntime.sleep(1)              # Wait 1 second\n\nfrom datetime import datetime\nnow = datetime.now()       # Current time\n\n# JSON handling\nimport json\ndata = json.loads('{\"temp\": 25.5}')  # Parse JSON\ntext = json.dumps(data)    # Convert to JSON\n\n# System operations\nimport os\npath = os.path.join('folder', 'file.txt')",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#code-style-guidelines",
    "href": "appendices/python_basics.html#code-style-guidelines",
    "title": "4  Python Basics",
    "section": "4.12 Code Style Guidelines",
    "text": "4.12 Code Style Guidelines\n\nUse clear, descriptive names\nUse snake_case for functions and variables\nAdd spaces around operators\nUse 4 spaces for indentation\nAdd comments for complex logic\nKeep functions focused and small\nHandle errors appropriately\n\nExample of well-styled code:\ndef calculate_average_temperature(readings):\n    \"\"\"Calculate average temperature from a list of readings.\"\"\"\n    if not readings:\n        return None\n        \n    try:\n        total = sum(readings)\n        return total / len(readings)\n    except Exception as e:\n        print(f\"Error calculating average: {e}\")\n        return None",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/python_basics.html#whats-next",
    "href": "appendices/python_basics.html#whats-next",
    "title": "4  Python Basics",
    "section": "4.13 What’s Next",
    "text": "4.13 What’s Next\nThis appendix covered the Python basics needed for our tutorial. As you work through the main chapters, refer back here if you need to review any concepts.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html",
    "href": "appendices/setup_guide.html",
    "title": "5  Setup Guide",
    "section": "",
    "text": "5.1 Installing uv\nThis guide will help you set up your Python development environment using uv, a modern alternative to traditional Python tooling. uv handles everything from Python installation to package management.\nFirst, let’s install uv:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#installing-uv",
    "href": "appendices/setup_guide.html#installing-uv",
    "title": "5  Setup Guide",
    "section": "",
    "text": "macOS or Linux:\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nWindows:\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#setting-up-python-with-uv",
    "href": "appendices/setup_guide.html#setting-up-python-with-uv",
    "title": "5  Setup Guide",
    "section": "5.2 Setting Up Python with uv",
    "text": "5.2 Setting Up Python with uv\nuv can manage Python versions for you. Let’s set up Python 3.11 (recommended for this tutorial):\nuv python 3.11\nThis command will: - Download Python 3.11 - Install it in a uv-managed location - Make it available for your projects",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#project-setup",
    "href": "appendices/setup_guide.html#project-setup",
    "title": "5  Setup Guide",
    "section": "5.3 Project Setup",
    "text": "5.3 Project Setup\n\nClone the Repository:\ngit clone https://github.com/Ameyanagi/StructuredPy\ncd StructuredPy\nCreate Virtual Environment:\nuv venv\nActivate Virtual Environment:\n\nWindows (PowerShell):\n.venv/Scripts/activate.ps1\nmacOS/Linux:\nsource .venv/bin/activate",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#installing-dependencies",
    "href": "appendices/setup_guide.html#installing-dependencies",
    "title": "5  Setup Guide",
    "section": "5.4 Installing Dependencies",
    "text": "5.4 Installing Dependencies\nInstall all project dependencies using uv:\nuv pip install -r requirements.txt\nThis will install packages much faster than traditional pip.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#ide-setup",
    "href": "appendices/setup_guide.html#ide-setup",
    "title": "5  Setup Guide",
    "section": "5.5 IDE Setup",
    "text": "5.5 IDE Setup\nWe recommend Visual Studio Code:\n\nInstall VS Code:\n\nDownload from code.visualstudio.com\n\nInstall Extensions:\n\nPython extension by Microsoft\nPylance for enhanced language support\n\nConfigure VS Code Settings:\nPress Cmd+, (macOS) or Ctrl+, (Windows/Linux) and add these settings:\n{\n    \"python.defaultInterpreterPath\": \"${workspaceFolder}/.venv/bin/python\",\n    \"python.analysis.typeCheckingMode\": \"basic\",\n    \"editor.formatOnSave\": true,\n    \"python.formatting.provider\": \"black\"\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#project-structure",
    "href": "appendices/setup_guide.html#project-structure",
    "title": "5  Setup Guide",
    "section": "5.6 Project Structure",
    "text": "5.6 Project Structure\nYour project structure should look like this:\nStructuredPy/\n├── .venv/                # Virtual environment\n├── chapters/            # Tutorial chapters\n├── code/                # Project code\n│   ├── timeseries/     # Time series analysis\n│   ├── device/         # Device communication\n│   └── api/            # API server\n└── requirements.txt     # Dependencies",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#verifying-installation",
    "href": "appendices/setup_guide.html#verifying-installation",
    "title": "5  Setup Guide",
    "section": "5.7 Verifying Installation",
    "text": "5.7 Verifying Installation\nRun these commands to verify your setup:\n# Should show Python 3.11.x\npython --version\n\n# Should show installed packages\nuv pip list",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#common-issues-and-solutions",
    "href": "appendices/setup_guide.html#common-issues-and-solutions",
    "title": "5  Setup Guide",
    "section": "5.8 Common Issues and Solutions",
    "text": "5.8 Common Issues and Solutions\n\nCommand Not Found:\n# Add uv to your PATH\nexport PATH=\"$HOME/.cargo/bin:$PATH\"  # macOS/Linux\n# or\n$Env:Path += \";$Home\\.cargo\\bin\"      # Windows PowerShell\nVirtual Environment Issues:\n# Remove and recreate\nrm -rf .venv\nuv venv\nPermission Issues:\n# macOS/Linux\nsudo chown -R $USER ~/.cargo\n\n# Windows (run as administrator)\ntakeown /F %USERPROFILE%\\.cargo /R",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#development-tools",
    "href": "appendices/setup_guide.html#development-tools",
    "title": "5  Setup Guide",
    "section": "5.9 Development Tools",
    "text": "5.9 Development Tools\nuv automatically handles development tools. Here’s how to use them:\n\nCode Formatting:\n# Format code\nuv pip install black\nblack .\nLinting:\n# Run linter\nuv pip install ruff\nruff check .\nTesting:\n# Run tests\nuv pip install pytest\npytest",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#best-practices",
    "href": "appendices/setup_guide.html#best-practices",
    "title": "5  Setup Guide",
    "section": "5.10 Best Practices",
    "text": "5.10 Best Practices\n\nAlways Use Virtual Environments:\n\nOne environment per project\nNever install packages globally\n\nDependencies Management:\n# Add new dependency\nuv pip install package_name\n\n# Update requirements.txt\nuv pip freeze &gt; requirements.txt\nKeep Python Updated:\n# Check available versions\nuv python --list\n\n# Install new version\nuv python 3.11",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#next-steps",
    "href": "appendices/setup_guide.html#next-steps",
    "title": "5  Setup Guide",
    "section": "5.11 Next Steps",
    "text": "5.11 Next Steps\n\nActivate your virtual environment\nCheck the Python basics appendix if needed\nStart with Chapter 1 of the tutorial\nJoin our community for help",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#additional-resources",
    "href": "appendices/setup_guide.html#additional-resources",
    "title": "5  Setup Guide",
    "section": "5.12 Additional Resources",
    "text": "5.12 Additional Resources\n\nuv Documentation\nVS Code Python\nModern Python Development Tools",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/setup_guide.html#getting-help",
    "href": "appendices/setup_guide.html#getting-help",
    "title": "5  Setup Guide",
    "section": "5.13 Getting Help",
    "text": "5.13 Getting Help\nIf you encounter any issues:\n\nCheck the uv issues page\nAsk in our GitHub discussions\nSearch Stack Overflow with the ‘uv-python’ tag\n\nRemember to keep your virtual environment active while working on the tutorial projects. You can always recreate it if something goes wrong.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Setup Guide</span>"
    ]
  },
  {
    "objectID": "appendices/resources.html",
    "href": "appendices/resources.html",
    "title": "",
    "section": "",
    "text": "Appendices6  resources.html Code",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>resources.html</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#strategy",
    "href": "chapters/01-timeseries-functions.html#strategy",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.3 Strategy",
    "text": "2.3 Strategy\nThe first thing that we have to do is to determine what we want to achieve with our analysis. In this case, we want to do something like this:\n\nData Loading and Validation\n\nLoad CSV files containing sensor data\nValidate timestamp formats\nCheck for missing values\nVerify data ranges\n\nBasic Statistics\n\nCalculate daily min/max/mean\nIdentify outliers\nCompute moving averages\n\nPattern Detection\n\nFind daily cycles\nDetect anomalies\nCalculate correlations between temperature and humidity\n\nVisualization\n\nPlot time series trends\nCreate daily pattern heatmaps\nGenerate statistical summaries\n\n\nThe main idea is to create functions that can be used to perform these tasks in a modular way. This will make our code more readable, reusable, and easier to maintain.",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#creating-functions",
    "href": "chapters/01-timeseries-functions.html#creating-functions",
    "title": "1  Time Series Analysis with Functions",
    "section": "1.4 Creating Functions",
    "text": "1.4 Creating Functions\n\n1.4.1 Data Management Functions\nLets start by creating the functions to load and validate our data. We will not implement the functions yet, just define there signature and purpose. This is called “function stubs”. This will help us to define the structure of our code. So that we can implement the functions later.\ndef load_sensor_data(filepath):\n    \"\"\"\n    Load sensor data from a CSV file.\n    \n    Example:\n        data = load_sensor_data('sensor_data.csv')\n    \"\"\"\n    pass\n\n\n\n\n\n\nTip\n\n\n\nThe pass statement is a placeholder that does nothing. It’s used as a temporary placeholder when a statement is required syntactically but you don’t want to execute any code.\n\n\n\n\n\n\n\n\nTip\n\n\n\nHere, we will be using the pandas library to load and manipulate our data. If you are not familiar with pandas, you can learn more about it in the official documentation.\n\n\nWe will also create a function to check the quality of our data:\n\nValidate timestamp formats\nCheck for missing values\nVerify data ranges\n\n\ndef validate_timestamp_format(data):\n    \"\"\"\n    Check if timestamp column has valid date formats.\n    \n    Example:\n        is_valid = validate_timestamp_format(data)\n    \"\"\"\n    pass\n\ndef check_missing_values(data):\n    \"\"\"\n    Check if data contains missing values.\n    \n    Example:\n        has_missing = check_missing_values(data)\n    \"\"\"\n    pass\n\ndef check_data_ranges(data):\n    \"\"\"\n    Check if data values are within expected ranges.\n\n    Example:\n        is_valid = check_data_ranges(data)\n    \"\"\"\n    pass\n\n\n\n\n\n\nNote\n\n\n\nHere, we are using splitting the validation into multiple functions to make it easier to understand. For real application, you can combine these functions in to a single function if you prefer.\n\n\nThen, we can create a function that combines all these checks, using the functions stubs we created:\ndef check_data_quality(data):\n    \"\"\"\n    Check if data has required columns and valid values.\n    \n    Example:\n        is_valid = check_data_quality(data)\n    \"\"\"\n\n    if not validate_timestamp_format(data):\n        raise ValueError(\"Invalid timestamp format\")\n\n    if check_missing_values(data):\n        raise ValueError(\"Data contains missing values\")\n\n    if not check_data_ranges(data):\n        raise ValueError(\"Data values are out of range\")\n\n    return True\nThe good thing about this approach even though we have not implemented the functions yet, we can create a downstream function that uses these functions. We can also note that the this approach will make it easier to test the functions independently.\n\n\n1.4.2 Analysis Functions\nNow, let’s create functions to analyze our data:\nThe functions will be organized as:\n\nData Management Functions\n\nload_sensor_data() - Load and validate CSV files\nclean_sensor_data() - Handle missing values and outliers\n\nAnalysis Functions\n\ncalculate_daily_stats() - Basic statistical measures\ndetect_patterns() - Find recurring patterns\nfind_anomalies() - Identify unusual readings\n\nVisualization Functions\n\nplot_timeseries() - Basic time series plots\nplot_daily_patterns() - Daily pattern visualization\nplot_statistics() - Statistical summary plots",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#analysis-functions-1",
    "href": "chapters/01-timeseries-functions.html#analysis-functions-1",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.7 Analysis Functions",
    "text": "2.7 Analysis Functions\nNow let’s create functions to analyze our data:\ndef calculate_basic_stats(data):\n    \"\"\"\n    Calculate basic statistics for temperature and humidity.\n    \n    Example:\n        stats = calculate_basic_stats(data)\n        print(f\"Average temperature: {stats['temp_mean']:.1f}°C\")\n    \"\"\"\n    stats = {\n        'temp_mean': data['temperature'].mean(),\n        'temp_max': data['temperature'].max(),\n        'temp_min': data['temperature'].min(),\n        'humid_mean': data['humidity'].mean(),\n        'readings_count': len(data)\n    }\n    return stats\n\ndef find_outliers(data, std_threshold=3):\n    \"\"\"\n    Find outlier readings based on standard deviation.\n    \n    Example:\n        outliers = find_outliers(data, std_threshold=2)\n    \"\"\"\n    temp_mean = data['temperature'].mean()\n    temp_std = data['temperature'].std()\n    \n    outliers = data[\n        abs(data['temperature'] - temp_mean) &gt; std_threshold * temp_std\n    ]\n    \n    return outliers",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#creating-that-function-stubs",
    "href": "chapters/01-timeseries-functions.html#creating-that-function-stubs",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.4 Creating that Function Stubs",
    "text": "2.4 Creating that Function Stubs\n\n2.4.1 Data Management Functions\nLets start by creating the functions to load and validate our data. We will not implement the functions yet, just define there signature and purpose. This is called “function stubs”. This will help us to define the structure of our code. So that we can implement the functions later.\ndef load_sensor_data(filepath):\n    \"\"\"\n    Load sensor data from a CSV file.\n    \n    Example:\n        data = load_sensor_data('sensor_data.csv')\n    \"\"\"\n    pass\n\n\n\n\n\n\nTip\n\n\n\nThe pass statement is a placeholder that does nothing. It’s used as a temporary placeholder when a statement is required syntactically but you don’t want to execute any code.\n\n\n\n\n\n\n\n\nTip\n\n\n\nHere, we will be using the pandas library to load and manipulate our data. If you are not familiar with pandas, you can learn more about it in the official documentation.\n\n\nWe will also create a function to check the quality of our data:\n\nValidate timestamp formats\nCheck for missing values\nVerify data ranges\n\n\ndef validate_timestamp_format(data):\n    \"\"\"\n    Check if timestamp column has valid date formats.\n    \n    Example:\n        is_valid = validate_timestamp_format(data)\n    \"\"\"\n    pass\n\ndef check_missing_values(data):\n    \"\"\"\n    Check if data contains missing values.\n    \n    Example:\n        has_missing = check_missing_values(data)\n    \"\"\"\n    pass\n\ndef check_data_ranges(data):\n    \"\"\"\n    Check if data values are within expected ranges.\n\n    Example:\n        is_valid = check_data_ranges(data)\n    \"\"\"\n    pass\n\n\n\n\n\n\nNote\n\n\n\nHere, we are using splitting the validation into multiple functions to make it easier to understand. For real application, you can combine these functions in to a single function if you prefer.\n\n\nThe good point of the functions stubs is that we can create a downstream function that uses these functions. For example, we can create a function that checks the quality of our data by combining these functions:\ndef check_data_quality(data):\n    \"\"\"\n    Check if data has required columns and valid values.\n    \n    Example:\n        is_valid = check_data_quality(data)\n    \"\"\"\n\n    if not validate_timestamp_format(data):\n        raise ValueError(\"Invalid timestamp format\")\n\n    if check_missing_values(data):\n        raise ValueError(\"Data contains missing values\")\n\n    if not check_data_ranges(data):\n        raise ValueError(\"Data values are out of range\")\n\n    return True\n\n\n2.4.2 Analysis Functions\nNow, let’s create function stubs to analyze our data:\ndef calculate_daily_stats(data):\n    \"\"\"\n    Calculate basic statistics for temperature and humidity.\n    \n    Example:\n        stats = calculate_daily_stats(data)\n        print(f\"Average temperature: {stats['temp_mean']:.1f}°C\")\n    \"\"\"\n    pass\n\ndef detect_patterns(data):\n    \"\"\"\n    Find recurring patterns in the data.\n\n    Example:\n        patterns = detect_patterns(data)\n    \"\"\"\n    pass\n\ndef find_anomalies(data):\n    \"\"\"\n    Identify unusual readings in the data.\n\n    Example:\n        anomalies = find_anomalies(data)\n    \"\"\"\n    pass\n\n\n2.4.3 Visualization Functions\nAdding functions to visualize our data:\ndef plot_timeseries(data):\n    \"\"\"\n    Create a line plot of temperature over time.\n    \n    Example:\n        plot_timeseries(data)\n        plt.show()\n    \"\"\"\n    pass\n\ndef plot_daily_patterns(data):\n    \"\"\"\n    Show daily patterns in temperature and humidity.\n\n    Example:\n        plot_daily_patterns(data)\n        plt.show()\n    \"\"\"\n    pass\n\ndef plot_statistics(data):\n    \"\"\"\n    Create statistical summary plots.\n\n    Example:\n        plot_statistics(data)\n        plt.show()\n    \"\"\"\n    pass",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#visualization-functions-1",
    "href": "chapters/01-timeseries-functions.html#visualization-functions-1",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.8 Visualization Functions",
    "text": "2.8 Visualization Functions\nAdding functions to visualize our data:\ndef plot_temperature_trend(data):\n    \"\"\"\n    Create a line plot of temperature over time.\n    \n    Example:\n        plot_temperature_trend(data)\n        plt.show()\n    \"\"\"\n    plt.figure(figsize=(12, 6))\n    plt.plot(data['timestamp'], data['temperature'])\n    plt.title('Temperature Over Time')\n    plt.xlabel('Time')\n    plt.ylabel('Temperature (°C)')\n    plt.grid(True)\n    \ndef plot_daily_pattern(data):\n    \"\"\"\n    Show average temperature pattern by hour of day.\n    \n    Example:\n        plot_daily_pattern(data)\n        plt.show()\n    \"\"\"\n    # Extract hour from timestamp\n    data['hour'] = data['timestamp'].dt.hour\n    \n    # Calculate mean temperature for each hour\n    daily_pattern = data.groupby('hour')['temperature'].mean()\n    \n    plt.figure(figsize=(10, 6))\n    daily_pattern.plot(kind='bar')\n    plt.title('Average Temperature by Hour')\n    plt.xlabel('Hour of Day')\n    plt.ylabel('Average Temperature (°C)')",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-timeseries-functions.html#writing-the-tests",
    "href": "chapters/01-timeseries-functions.html#writing-the-tests",
    "title": "2  Time Series Analysis with Functions",
    "section": "2.5 Writing the Tests",
    "text": "2.5 Writing the Tests\n\n\n\n\n\n\nNote\n\n\n\nYou can skip this section if you are not familiar with testing. You can come back to this section later when you are ready to learn about testing.\n\n\nNow that we have defined the functions, we can write tests to check if they work as expected. This is called “unit testing”. The test will help us to check if the functions are working as expected. The workflow of writing the test and the function is called “Test Driven Development” (TDD).\nHere is an example of how to write tests for the load_sensor_data function:\ntimestamp,temperature,humidity\n2024-01-01 00:00:00,22.5,45\n2024-01-01 00:01:00,22.6,46\n2024-01-01 00:02:00,22.4,45\ntimestamp,temperature,humidity\n2024-01-01 00:00:00,22.5,45\n2024-01-01 00:01:00,22.6,46\n2024-01-01 00:02:00,22.4,\ndef test_load_sensor_data():\n    # Test loading a valid file\n    data = load_sensor_data('sensor_data.csv')\n    assert data is not None, \"Failed to load valid file\"\n    \n    # Test loading a non-existent file\n    data = load_sensor_data('non_existent.csv')\n    assert data is None, \"Loaded non-existent file\"\n\n    # Test loading a file with missing values\n    data = load_sensor_data('sensor_data_missing.csv')\n    assert data is None, \"Loaded file with missing values\"\n\n    # Test loading a file with invalid timestamp\n    data = load_sensor_data('sensor_data_invalid.csv')\n    assert data is None, \"Loaded file with invalid timestamp\"",
    "crumbs": [
      "Time Series Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Time Series Analysis with Functions</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html",
    "href": "chapters/01-initial-setting-and-tutorial.html",
    "title": "1  Initial Setting and Tutorial",
    "section": "",
    "text": "1.1 Prerequisites\nThis tutorial will guide you through setting up a modern Python development environment with best practices for:\nBy following this guide, you’ll create a well-structured Python project that follows some of the best practices that people use for python. The setup includes automatic testing, documentation generation, and code quality checks - essential tools for professional Python development.\nBefore starting this tutorial, you should have:\nBut if you don’t have any of these, don’t worry! You can refer to the Appendix for more information.",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#initial-setup",
    "href": "chapters/01-initial-setting-and-tutorial.html#initial-setup",
    "title": "2  Initial Setting and Tutorial",
    "section": "4.1 Initial Setup",
    "text": "4.1 Initial Setup\nYou first have to install git to the system. Then you can set your user name and email address with the following commands:\ngit config --global user.email \"you@example.com\"\ngit config --global user.name \"Your Name\"\ngit config --global credential.helper store\nThe email and name are used to identify the author of the commits. The credential helper will store your GitHub token so you don’t have to enter it every time you push changes.",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#installation",
    "href": "chapters/01-initial-setting-and-tutorial.html#installation",
    "title": "2  Initial Setting and Tutorial",
    "section": "6.1 Installation",
    "text": "6.1 Installation\nYou can install uv by running the following command:\ncurl -LsSf https://astral.sh/uv/install.sh | sh",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#boilerplate-by-cookiecutter",
    "href": "chapters/01-initial-setting-and-tutorial.html#boilerplate-by-cookiecutter",
    "title": "2  Initial Setting and Tutorial",
    "section": "7.1 Boilerplate by cookiecutter",
    "text": "7.1 Boilerplate by cookiecutter\nInitializing a new project in a best practice way is not easy to do it by yourself. The most easiest way to do it is to use a boilerplate. There are many boilerplates available on GitHub, but one of the most popular ones is the cookiecutter template. Here, we will be using cookiecutter-uv created by fpgmaas. You can find the template here\nuvx cookiecutter https://github.com/fpgmaas/cookiecutter-uv.git\nOnce you run the command, you will be prompted to enter some information about your project. This information will be used to generate the project structure and files.\nInstalled 22 packages in 11ms\n  [1/14] author (Florian Maas): Ameyanagi\n  [2/14] email (fpgmaas@gmail.com): contact@ameyanagi.com\n  [3/14] author_github_handle (fpgmaas): Ameyanagi\n  [4/14] project_name (example-project): StructuredPy-code\n  [5/14] project_slug (structuredpy_code):\n  [6/14] project_description (This is a template repository for Python projects that use uv for their dependency management.): This is a repository containing the example project used in the StructuredPy\n  [7/14] Select include_github_actions\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [8/14] Select publish_to_pypi\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [9/14] Select deptry\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [10/14] Select mkdocs\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [11/14] Select codecov\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [12/14] Select dockerfile\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [13/14] Select devcontainer\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [14/14] Select open_source_license\n    1 - MIT license\n    2 - BSD license\n    3 - ISC license\n    4 - Apache Software License 2.0\n    5 - GNU General Public License v3\n    6 - Not open source\n    Choose from [1/2/3/4/5/6] (1):",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#project-directory",
    "href": "chapters/01-initial-setting-and-tutorial.html#project-directory",
    "title": "2  Initial Setting and Tutorial",
    "section": "7.2 Project directory",
    "text": "7.2 Project directory\nYou can check the initial directory tree by running the following command:\ntree -a -L 4 StructuredPy-code # Please change the directory name to your project name or a directory name you specified in the cookiecutter command\nThe output will be like this:\nStructuredPy-code\n├── codecov.yaml\n├── CONTRIBUTING.md\n├── .devcontainer\n│   ├── devcontainer.json\n│   └── postCreateCommand.sh\n├── Dockerfile\n├── docs\n│   ├── index.md\n│   └── modules.md\n├── .editorconfig\n├── .github\n│   ├── actions\n│   │   └── setup-python-env\n│   │       └── action.yml\n│   └── workflows\n│       ├── main.yml\n│       ├── on-release-main.yml\n│       └── validate-codecov-config.yml\n├── .gitignore\n├── LICENSE\n├── Makefile\n├── mkdocs.yml\n├── .pre-commit-config.yaml\n├── pyproject.toml\n├── README.md\n├── structuredpy_code\n│   ├── foo.py\n│   └── __init__.py\n├── tests\n│   └── test_foo.py\n└── tox.ini\n\n9 directories, 23 files",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#initializing-git-repository",
    "href": "chapters/01-initial-setting-and-tutorial.html#initializing-git-repository",
    "title": "2  Initial Setting and Tutorial",
    "section": "7.3 Initializing git repository",
    "text": "7.3 Initializing git repository\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/Ameyanagi/StructuredPy-code.git\ngit push -u origin main",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#installing-the-python-dependencies",
    "href": "chapters/01-initial-setting-and-tutorial.html#installing-the-python-dependencies",
    "title": "2  Initial Setting and Tutorial",
    "section": "7.4 Installing the python dependencies",
    "text": "7.4 Installing the python dependencies\nmake install\nThis will run the following command:\nuv sync\nuv run pre-commit install\nThe output will be like this:\n🚀 Creating virtual environment using uv\nUsing CPython 3.13.1 interpreter at: /usr/bin/python3\nCreating virtual environment at: .venv\nResolved 63 packages in 620ms\n   Built structuredpy-code @ file:///home/ameyanagi/StructuredPy-code\nPrepared 59 packages in 1.12s\nInstalled 59 packages in 169ms\n + babel==2.16.0\n + cachetools==5.5.0\n + certifi==2024.12.14\n + cfgv==3.4.0\n + chardet==5.2.0\n + charset-normalizer==3.4.1\n + click==8.1.8\n + colorama==0.4.6\n + coverage==7.6.10\n + deptry==0.21.2\n + distlib==0.3.9\n + filelock==3.16.1\n + ghp-import==2.1.0\n + griffe==1.5.4\n + identify==2.6.5\n + idna==3.10\n + iniconfig==2.0.0\n + jinja2==3.1.5\n + markdown==3.7\n + markupsafe==3.0.2\n + mergedeep==1.3.4\n + mkdocs==1.6.1\n + mkdocs-autorefs==1.2.0\n + mkdocs-get-deps==0.2.0\n + mkdocs-material==9.5.49\n + mkdocs-material-extensions==1.3.1\n + mkdocstrings==0.27.0\n + mkdocstrings-python==1.13.0\n + mypy==1.14.1\n + mypy-extensions==1.0.0\n + nodeenv==1.9.1\n + packaging==24.2\n + paginate==0.5.7\n + pathspec==0.12.1\n + platformdirs==4.3.6\n + pluggy==1.5.0\n + pre-commit==4.0.1\n + pygments==2.19.1\n + pymdown-extensions==10.13\n + pyproject-api==1.8.0\n + pytest==8.3.4\n + pytest-cov==6.0.0\n + python-dateutil==2.9.0.post0\n + pyyaml==6.0.2\n + pyyaml-env-tag==0.1\n + regex==2024.11.6\n + requests==2.32.3\n + requirements-parser==0.11.0\n + ruff==0.8.6\n + six==1.17.0\n + structuredpy-code==0.0.1 (from file:///home/ameyanagi/StructuredPy-code)\n + tox==4.23.2\n + tox-uv==1.17.0\n + types-setuptools==75.6.0.20241223\n + typing-extensions==4.12.2\n + urllib3==2.3.0\n + uv==0.5.15\n + virtualenv==20.28.1\n + watchdog==6.0.0\npre-commit installed at .git/hooks/pre-commit",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#open-code-in-xx",
    "href": "chapters/01-initial-setting-and-tutorial.html#open-code-in-xx",
    "title": "2  Initial Setting and Tutorial",
    "section": "8.1 Open code in XX",
    "text": "8.1 Open code in XX",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#running-the-code",
    "href": "chapters/01-initial-setting-and-tutorial.html#running-the-code",
    "title": "2  Initial Setting and Tutorial",
    "section": "8.2 Running the code",
    "text": "8.2 Running the code\nThe source code is included in the structuredpy_code directory. By default the foo.py file is included in the directory. You can run the code by running the following command:\nuv run structuredpy_code/foo.py\nAt this moment, there will be no output, because the foo.py file is empty.\ndef foo(bar: str) -&gt; str:\n    \"\"\"Summary line.\n\n    Extended description of function.\n\n    Args:\n        bar: Description of input argument.\n\n    Returns:\n        Description of return value\n    \"\"\"\n\n    return bar\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    pass\nWe will be make a new file and work on that file, but configuration would be the same.",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#creating-a-python-file-and-running-it",
    "href": "chapters/01-initial-setting-and-tutorial.html#creating-a-python-file-and-running-it",
    "title": "2  Initial Setting and Tutorial",
    "section": "8.3 Creating a python file and running it",
    "text": "8.3 Creating a python file and running it\nLet’s create a new file called hello.py in the structuredpy_code directory. In the hello.py file, we will write a simple function that prints “hello world” to the console.\ndef main():\n    print(\"hello world\")\n\n\nif __name__ == \"__main__\":\n    main()\nYou can run the code by running the following command:\nuv run structuredpy_code/hello.py\nThe output will be like this:\nhello world",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#test-the-code",
    "href": "chapters/01-initial-setting-and-tutorial.html#test-the-code",
    "title": "2  Initial Setting and Tutorial",
    "section": "8.4 Test the code",
    "text": "8.4 Test the code\nLet’s look at the test file in the tests directory. The test file is called test_foo.py and it tests the foo function in the foo.py file.\n```python\nfrom structuredpy_code.foo import foo\n\n\ndef test_foo():\n    assert foo(\"foo\") == \"foo\"\n\n8.4.1 Running the test\nYou can run the test by running the following command:\nmake test\nThis command will run the following command:\nuv run python -m pytest --cov --cov-config=pyproject.toml --cov-report=xml\nThe output will be like this:\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 1 item\n\ntests/test_foo.py .                                                                                                                                 [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 1 passed in 0.03s ====================================================================\nWhat this does is that it runs the test file cnd see if the code runs with out the error. In the test_foo.py file, we are testing the foo function in the foo.py file will return the same string that we passed to it. assert is a keyword that is used to check if the condition is true. If the condition is false, it will raise an AssertionError.\n\n\n8.4.2 Basics of Test Driven Development (TDD)\nTDD is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved so that the tests pass. The cycle is repeated until the software is complete.\nLet’s assume we want to add a new function called add in the foo.py file. We will first create a add function stub in the test_foo.py file.\ndef add(a, b):\n    pass\nThen in the test_foo.py file, we will write a test for the add function. Here, we will write 4 tests for the add function to check if the function works as expected.\nfrom structuredpy_code.foo import add\n\ndef test_add():\n    assert add(1, 2) == 3\n\ndef test_add_negative():\n    assert add(-1, -2) == -3\n\ndef test_add_zero():\n    assert add(0, 0) == 0\n\ndef test_add_float():\n    assert add(1.5, 2.5) == 4.0\nThen we will run the test by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .FFFF                                                                                                                             [100%]\n\n======================================================================== FAILURES =========================================================================\n________________________________________________________________________ test_add _________________________________________________________________________\n\n    def test_add():\n&gt;       assert add(1, 2) == 3\nE       assert None == 3\nE        +  where None = add(1, 2)\n\ntests/test_foo.py:9: AssertionError\n____________________________________________________________________ test_add_negative ____________________________________________________________________\n\n    def test_add_negative():\n&gt;       assert add(-1, -2) == -3\nE       assert None == -3\nE        +  where None = add(-1, -2)\n\ntests/test_foo.py:13: AssertionError\n______________________________________________________________________ test_add_zero ______________________________________________________________________\n\n    def test_add_zero():\n&gt;       assert add(0, 0) == 0\nE       assert None == 0\nE        +  where None = add(0, 0)\n\ntests/test_foo.py:17: AssertionError\n_____________________________________________________________________ test_add_float ______________________________________________________________________\n\n    def test_add_float():\n&gt;       assert add(1.5, 2.5) == 4.0\nE       assert None == 4.0\nE        +  where None = add(1.5, 2.5)\n\ntests/test_foo.py:21: AssertionError\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n================================================================= short test summary info =================================================================\nFAILED tests/test_foo.py::test_add - assert None == 3\nFAILED tests/test_foo.py::test_add_negative - assert None == -3\nFAILED tests/test_foo.py::test_add_zero - assert None == 0\nFAILED tests/test_foo.py::test_add_float - assert None == 4.0\n=============================================================== 4 failed, 1 passed in 0.09s ===============================================================\nmake: *** [Makefile:21: test] Error 1\nWe now see that all the tests have failed, because we have not implemented the add function yet. The main idea of TDD is to write the test first, then implement the function to make the test pass.\nLet’s implement the add function in the foo.py file to make the test pass.\ndef add(a, b):\n    return a + b\nThen run the test again by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .....                                                                                                                             [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 5 passed in 0.03s ====================================================================",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#commit-the-code-to-git",
    "href": "chapters/01-initial-setting-and-tutorial.html#commit-the-code-to-git",
    "title": "2  Initial Setting and Tutorial",
    "section": "9.1 Commit the code to Git",
    "text": "9.1 Commit the code to Git\nYou can commit the code to Git by running the following command:\ngit add .\ngit commit -m \"add add function\"\nThe output will be like this:\n[INFO] Initializing environment for https://github.com/pre-commit/pre-commit-hooks.\n[WARNING] repo `https://github.com/pre-commit/pre-commit-hooks` uses deprecated stage names (commit, push) which will be removed in a future version.  Hint: often `pre-commit autoupdate --repo https://github.com/pre-commit/pre-commit-hooks` will fix this.  if it does not -- consider reporting an issue to that repo.\n[INFO] Initializing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier:prettier@3.0.3.\n[INFO] Installing environment for https://github.com/pre-commit/pre-commit-hooks.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\ncheck for case conflicts.................................................Passed\ncheck for merge conflicts................................................Passed\ncheck toml...........................................(no files to check)Skipped\ncheck yaml...........................................(no files to check)Skipped\nfix end of files.........................................................Passed\ntrim trailing whitespace.................................................Passed\nruff.....................................................................Passed\nruff-format..............................................................Passed\nprettier.................................................................Passed\n[main 233db95] add add function\n 4 files changed, 1232 insertions(+), 1 deletion(-)\n create mode 100644 structuredpy_code/hello.py\n create mode 100644 uv.lock\nThere will be whole bunch of output, because there is a pre-commit hook that runs when you commit the code to Git. This is important to keep the code clean and consistent,\nThen if you want to push the code to GitHub, you can run the following command:\ngit push",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#prerequisites",
    "href": "chapters/01-initial-setting-and-tutorial.html#prerequisites",
    "title": "1  Initial Setting and Tutorial",
    "section": "",
    "text": "Basic Python knowledge\nA GitHub account\nA text editor or IDE of your choice\nTerminal/command line familiarity",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#git",
    "href": "chapters/01-initial-setting-and-tutorial.html#git",
    "title": "2  Initial Setting and Tutorial",
    "section": "2.2 Git",
    "text": "2.2 Git\n\n2.2.1 Initial Setup\nYou first have to install git to the system. Then you can set your user name and email address with the following commands:\ngit config --global user.email \"you@example.com\"\ngit config --global user.name \"Your Name\"\ngit config --global credential.helper store\nThe email and name are used to identify the author of the commits. The credential helper will store your GitHub token so you don’t have to enter it every time you push changes.",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#github-token",
    "href": "chapters/01-initial-setting-and-tutorial.html#github-token",
    "title": "2  Initial Setting and Tutorial",
    "section": "2.3 GitHub Token",
    "text": "2.3 GitHub Token\nWhenever you push changes to GitHub, you will be prompted to enter your Github username and GitHub token. You can generate a new token by going to your GitHub settings and selecting “Developer settings” &gt; “Personal access tokens” &gt; “Generate new token”. Make sure to select the “repo” scope so you can push changes to your repositories.",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#uv",
    "href": "chapters/01-initial-setting-and-tutorial.html#uv",
    "title": "2  Initial Setting and Tutorial",
    "section": "2.4 uv",
    "text": "2.4 uv\n\n2.4.1 Installation\nYou can install uv by running the following command:\ncurl -LsSf https://astral.sh/uv/install.sh | sh",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#project-initialization",
    "href": "chapters/01-initial-setting-and-tutorial.html#project-initialization",
    "title": "2  Initial Setting and Tutorial",
    "section": "2.5 Project initialization",
    "text": "2.5 Project initialization\n\n2.5.1 Boilerplate by cookiecutter\nInitializing a new project in a best practice way is not easy to do it by yourself. The most easiest way to do it is to use a boilerplate. There are many boilerplates available on GitHub, but one of the most popular ones is the cookiecutter template. Here, we will be using cookiecutter-uv created by fpgmaas. You can find the template here\nuvx cookiecutter https://github.com/fpgmaas/cookiecutter-uv.git\nOnce you run the command, you will be prompted to enter some information about your project. This information will be used to generate the project structure and files.\nInstalled 22 packages in 11ms\n  [1/14] author (Florian Maas): Ameyanagi\n  [2/14] email (fpgmaas@gmail.com): contact@ameyanagi.com\n  [3/14] author_github_handle (fpgmaas): Ameyanagi\n  [4/14] project_name (example-project): StructuredPy-code\n  [5/14] project_slug (structuredpy_code):\n  [6/14] project_description (This is a template repository for Python projects that use uv for their dependency management.): This is a repository containing the example project used in the StructuredPy\n  [7/14] Select include_github_actions\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [8/14] Select publish_to_pypi\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [9/14] Select deptry\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [10/14] Select mkdocs\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [11/14] Select codecov\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [12/14] Select dockerfile\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [13/14] Select devcontainer\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [14/14] Select open_source_license\n    1 - MIT license\n    2 - BSD license\n    3 - ISC license\n    4 - Apache Software License 2.0\n    5 - GNU General Public License v3\n    6 - Not open source\n    Choose from [1/2/3/4/5/6] (1):\n\n\n2.5.2 Project directory\nYou can check the initial directory tree by running the following command:\ntree -a -L 4 StructuredPy-code # Please change the directory name to your project name or a directory name you specified in the cookiecutter command\nThe output will be like this:\nStructuredPy-code\n├── codecov.yaml\n├── CONTRIBUTING.md\n├── .devcontainer\n│   ├── devcontainer.json\n│   └── postCreateCommand.sh\n├── Dockerfile\n├── docs\n│   ├── index.md\n│   └── modules.md\n├── .editorconfig\n├── .github\n│   ├── actions\n│   │   └── setup-python-env\n│   │       └── action.yml\n│   └── workflows\n│       ├── main.yml\n│       ├── on-release-main.yml\n│       └── validate-codecov-config.yml\n├── .gitignore\n├── LICENSE\n├── Makefile\n├── mkdocs.yml\n├── .pre-commit-config.yaml\n├── pyproject.toml\n├── README.md\n├── structuredpy_code\n│   ├── foo.py\n│   └── __init__.py\n├── tests\n│   └── test_foo.py\n└── tox.ini\n\n9 directories, 23 files\n\n\n2.5.3 Initializing git repository\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/Ameyanagi/StructuredPy-code.git\ngit push -u origin main\n\n\n2.5.4 Installing the python dependencies\nmake install\nThis will run the following command:\nuv sync\nuv run pre-commit install\nThe output will be like this:\n🚀 Creating virtual environment using uv\nUsing CPython 3.13.1 interpreter at: /usr/bin/python3\nCreating virtual environment at: .venv\nResolved 63 packages in 620ms\n   Built structuredpy-code @ file:///home/ameyanagi/StructuredPy-code\nPrepared 59 packages in 1.12s\nInstalled 59 packages in 169ms\n + babel==2.16.0\n + cachetools==5.5.0\n + certifi==2024.12.14\n + cfgv==3.4.0\n + chardet==5.2.0\n + charset-normalizer==3.4.1\n + click==8.1.8\n + colorama==0.4.6\n + coverage==7.6.10\n + deptry==0.21.2\n + distlib==0.3.9\n + filelock==3.16.1\n + ghp-import==2.1.0\n + griffe==1.5.4\n + identify==2.6.5\n + idna==3.10\n + iniconfig==2.0.0\n + jinja2==3.1.5\n + markdown==3.7\n + markupsafe==3.0.2\n + mergedeep==1.3.4\n + mkdocs==1.6.1\n + mkdocs-autorefs==1.2.0\n + mkdocs-get-deps==0.2.0\n + mkdocs-material==9.5.49\n + mkdocs-material-extensions==1.3.1\n + mkdocstrings==0.27.0\n + mkdocstrings-python==1.13.0\n + mypy==1.14.1\n + mypy-extensions==1.0.0\n + nodeenv==1.9.1\n + packaging==24.2\n + paginate==0.5.7\n + pathspec==0.12.1\n + platformdirs==4.3.6\n + pluggy==1.5.0\n + pre-commit==4.0.1\n + pygments==2.19.1\n + pymdown-extensions==10.13\n + pyproject-api==1.8.0\n + pytest==8.3.4\n + pytest-cov==6.0.0\n + python-dateutil==2.9.0.post0\n + pyyaml==6.0.2\n + pyyaml-env-tag==0.1\n + regex==2024.11.6\n + requests==2.32.3\n + requirements-parser==0.11.0\n + ruff==0.8.6\n + six==1.17.0\n + structuredpy-code==0.0.1 (from file:///home/ameyanagi/StructuredPy-code)\n + tox==4.23.2\n + tox-uv==1.17.0\n + types-setuptools==75.6.0.20241223\n + typing-extensions==4.12.2\n + urllib3==2.3.0\n + uv==0.5.15\n + virtualenv==20.28.1\n + watchdog==6.0.0\npre-commit installed at .git/hooks/pre-commit",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#editing-the-code",
    "href": "chapters/01-initial-setting-and-tutorial.html#editing-the-code",
    "title": "1  Initial Setting and Tutorial",
    "section": "2.3 Editing the code",
    "text": "2.3 Editing the code\n\n2.3.1 Open code in XX\n\n\n2.3.2 Running the code\nThe source code is included in the structuredpy_code directory. By default the foo.py file is included in the directory. You can run the code by running the following command:\nuv run structuredpy_code/foo.py\nAt this moment, there will be no output, because the foo.py file is empty.\ndef foo(bar: str) -&gt; str:\n    \"\"\"Summary line.\n\n    Extended description of function.\n\n    Args:\n        bar: Description of input argument.\n\n    Returns:\n        Description of return value\n    \"\"\"\n\n    return bar\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    pass\nWe will be make a new file and work on that file, but configuration would be the same.\n\n\n2.3.3 Creating a python file and running it\nLet’s create a new file called hello.py in the structuredpy_code directory. In the hello.py file, we will write a simple function that prints “hello world” to the console.\ndef main():\n    print(\"hello world\")\n\n\nif __name__ == \"__main__\":\n    main()\nYou can run the code by running the following command:\nuv run structuredpy_code/hello.py\nThe output will be like this:\nhello world\n\n\n2.3.4 Test the code\nLet’s look at the test file in the tests directory. The test file is called test_foo.py and it tests the foo function in the foo.py file.\n```python\nfrom structuredpy_code.foo import foo\n\n\ndef test_foo():\n    assert foo(\"foo\") == \"foo\"\n\n2.3.4.1 Running the test\nYou can run the test by running the following command:\nmake test\nThis command will run the following command:\nuv run python -m pytest --cov --cov-config=pyproject.toml --cov-report=xml\nThe output will be like this:\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 1 item\n\ntests/test_foo.py .                                                                                                                                 [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 1 passed in 0.03s ====================================================================\nWhat this does is that it runs the test file cnd see if the code runs with out the error. In the test_foo.py file, we are testing the foo function in the foo.py file will return the same string that we passed to it. assert is a keyword that is used to check if the condition is true. If the condition is false, it will raise an AssertionError.\n\n\n2.3.4.2 Basics of Test Driven Development (TDD)\nTDD is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved so that the tests pass. The cycle is repeated until the software is complete.\nLet’s assume we want to add a new function called add in the foo.py file. We will first create a add function stub in the test_foo.py file.\ndef add(a, b):\n    pass\nThen in the test_foo.py file, we will write a test for the add function. Here, we will write 4 tests for the add function to check if the function works as expected.\nfrom structuredpy_code.foo import add\n\ndef test_add():\n    assert add(1, 2) == 3\n\ndef test_add_negative():\n    assert add(-1, -2) == -3\n\ndef test_add_zero():\n    assert add(0, 0) == 0\n\ndef test_add_float():\n    assert add(1.5, 2.5) == 4.0\nThen we will run the test by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .FFFF                                                                                                                             [100%]\n\n======================================================================== FAILURES =========================================================================\n________________________________________________________________________ test_add _________________________________________________________________________\n\n    def test_add():\n&gt;       assert add(1, 2) == 3\nE       assert None == 3\nE        +  where None = add(1, 2)\n\ntests/test_foo.py:9: AssertionError\n____________________________________________________________________ test_add_negative ____________________________________________________________________\n\n    def test_add_negative():\n&gt;       assert add(-1, -2) == -3\nE       assert None == -3\nE        +  where None = add(-1, -2)\n\ntests/test_foo.py:13: AssertionError\n______________________________________________________________________ test_add_zero ______________________________________________________________________\n\n    def test_add_zero():\n&gt;       assert add(0, 0) == 0\nE       assert None == 0\nE        +  where None = add(0, 0)\n\ntests/test_foo.py:17: AssertionError\n_____________________________________________________________________ test_add_float ______________________________________________________________________\n\n    def test_add_float():\n&gt;       assert add(1.5, 2.5) == 4.0\nE       assert None == 4.0\nE        +  where None = add(1.5, 2.5)\n\ntests/test_foo.py:21: AssertionError\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n================================================================= short test summary info =================================================================\nFAILED tests/test_foo.py::test_add - assert None == 3\nFAILED tests/test_foo.py::test_add_negative - assert None == -3\nFAILED tests/test_foo.py::test_add_zero - assert None == 0\nFAILED tests/test_foo.py::test_add_float - assert None == 4.0\n=============================================================== 4 failed, 1 passed in 0.09s ===============================================================\nmake: *** [Makefile:21: test] Error 1\nWe now see that all the tests have failed, because we have not implemented the add function yet. The main idea of TDD is to write the test first, then implement the function to make the test pass.\nLet’s implement the add function in the foo.py file to make the test pass.\ndef add(a, b):\n    return a + b\nThen run the test again by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .....                                                                                                                             [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 5 passed in 0.03s ====================================================================",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#docs",
    "href": "chapters/01-initial-setting-and-tutorial.html#docs",
    "title": "1  Initial Setting and Tutorial",
    "section": "2.4 Docs",
    "text": "2.4 Docs\nDocumentation is a very important part of programming, but it is not always easy to write documentation. In this work flow we will be using the docstring to write the documentation for the code. We will be using the mkdocs to generate the documentation for the code.\nmake docs\nThis will run the following command:\nuv run mkdocs serve\nThe output will be like this:\nmake docs\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nINFO    -  Documentation built in 0.25 seconds\nINFO    -  [02:42:02] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO    -  [02:42:02] Serving on http://127.0.0.1:8000/StructuredPy-code/\nIn this case, the documentation will be available at http://127.0.0.1:8000/StructuredPy-code/ in your web browser. You can quickly see that the documentation of the foo function is available in module section of the documentation, but the add function is not available in the documentation. This is because the add function does not have a docstring.\nThe docstring is a string that is used to document the code. It is written in the first line of the function, class, or module. There are several formats for writing docstrings, but we will be using the Google style for writing docstrings.\nLet’s add a docstring to the add function in the foo.py file.\ndef add(a, b):\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nThen run the test again by running the following command:\nmake docs\nYou can check from the docs that the add function is now available in the documentation. We have to note that the type definition is not available in the documentation, because we have not added the type definition to the function. Let’s add the type definition to the add function in the foo.py file.\ndef add(a: number, b: int) -&gt; int:\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nNow we can see that the type definition is now available in the documentation. The type definition is not necessary for the code to run, but it is a good practice to add the type definition to the function in terms of readability and maintainability of the code.\n\n2.4.1 Commit the code to Git\nYou can commit the code to Git by running the following command:\ngit add .\ngit commit -m \"add add function\"\nThe output will be like this:\n[INFO] Initializing environment for https://github.com/pre-commit/pre-commit-hooks.\n[WARNING] repo `https://github.com/pre-commit/pre-commit-hooks` uses deprecated stage names (commit, push) which will be removed in a future version.  Hint: often `pre-commit autoupdate --repo https://github.com/pre-commit/pre-commit-hooks` will fix this.  if it does not -- consider reporting an issue to that repo.\n[INFO] Initializing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier:prettier@3.0.3.\n[INFO] Installing environment for https://github.com/pre-commit/pre-commit-hooks.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\ncheck for case conflicts.................................................Passed\ncheck for merge conflicts................................................Passed\ncheck toml...........................................(no files to check)Skipped\ncheck yaml...........................................(no files to check)Skipped\nfix end of files.........................................................Passed\ntrim trailing whitespace.................................................Passed\nruff.....................................................................Passed\nruff-format..............................................................Passed\nprettier.................................................................Passed\n[main 233db95] add add function\n 4 files changed, 1232 insertions(+), 1 deletion(-)\n create mode 100644 structuredpy_code/hello.py\n create mode 100644 uv.lock\nThere will be whole bunch of output, because there is a pre-commit hook that runs when you commit the code to Git. This is important to keep the code clean and consistent,\nThen if you want to push the code to GitHub, you can run the following command:\ngit push",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#setting-up-git",
    "href": "chapters/01-initial-setting-and-tutorial.html#setting-up-git",
    "title": "1  Initial Setting and Tutorial",
    "section": "1.2 Setting up Git",
    "text": "1.2 Setting up Git\n\n1.2.1 Initial Setup\n\n1.2.1.1 Installing Git\nBefore you can use Git, you need to install it on your system:\n\nWindows: Download and install from git-scm.com\nmacOS: Install via Homebrew: brew install git\nLinux: Install via package manager:\n# Ubuntu/Debian\nsudo apt-get install git\n\n# Fedora\nsudo dnf install git\n\n\n\n\n1.2.2 Configuring Git\nAfter installation, configure your identity: This will be required when you are pushing the code to the GitHub.\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"you@example.com\"\nAdditional recommended configurations: Whenever you are pushing to the GitHub, you will be asked for the username and password. To avoid this, you can store the credentials securely. If you are not using GitHub, then you can skip this step.\n# Store credentials securely\ngit config --global credential.helper store",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#github-setup",
    "href": "chapters/01-initial-setting-and-tutorial.html#github-setup",
    "title": "2  Initial Setting and Tutorial",
    "section": "2.3 GitHub Setup",
    "text": "2.3 GitHub Setup\nGitHub is a popular platform for hosting Git repositories and collaborating on code. You can use it to store your code, track changes, and work with others on projects. You can also use GitHub Actions for continuous integration and deployment (CI/CD) workflows.\nYou will need to create an account on GitHub and set up a personal access token to push code to GitHub.\n\n2.3.1 Creating a GitHub Account (This is optional if you are not going to make a backup on GitHub)\n\nGo to github.com and sign up for an account\nVerify your email address\nSet up two-factor authentication (recommended)\n\n\n\n2.3.2 Creating a Personal Access Token\nModern GitHub security requires using tokens instead of passwords:\n\nGo to GitHub Settings → Developer settings → Personal access tokens → Tokens (classic)\nClick “Generate new token (classic)”\nSelect scopes:\n\nrepo (Full control of private repositories)\nworkflow (if using GitHub Actions)\nread:org (if working with organization repositories)\n\nSet an expiration date\nGenerate and copy the token immediately (it won’t be shown again)\n\nStore your token securely - you’ll need it when pushing to GitHub.",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#uv-modern-python-package-management",
    "href": "chapters/01-initial-setting-and-tutorial.html#uv-modern-python-package-management",
    "title": "1  Initial Setting and Tutorial",
    "section": "1.4 uv: Modern Python Package Management",
    "text": "1.4 uv: Modern Python Package Management\nuv is a new-generation Python package installer and resolver written in Rust. It offers several advantages over traditional tools like pip:\n\nExtremely fast package installation and dependency resolution\nBuilt-in virtual environment management\nCompatible with pip’s interface and package formats\nReliable dependency resolution\nOptimized for modern Python development\n\nHere, we will only be focusing on the installation and minimal validation of the uv that is required for the project.\nIf you want to know more about uv, you can visit the official website here\n\n1.4.1 Installation\n\n1.4.1.1 Installation Methods\n\nUnix/macOS\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nWindows (PowerShell)\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n\n\n\n\n\n\nNote\n\n\n\nNote: After installation on Windows, you may need to add uv to your PATH. The installation location is %USERPROFILE%\\.local\\bin. You can add this to your PATH by:\n\nPress Windows + X and select “System”\nClick “Advanced system settings”\nClick “Environment Variables”\nUnder “User variables”, find and select “Path”\nClick “Edit”\nClick “New”\nAdd %USERPROFILE%\\.local\\bin\nClick “OK” on all windows\n\n\n\n\n\n\n1.4.2 Verifying Installation\nYou can verify the installation by opening a new terminal or PowerShell window and running:\nuv --version",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#what-is-uv",
    "href": "chapters/01-initial-setting-and-tutorial.html#what-is-uv",
    "title": "2  Initial Setting and Tutorial",
    "section": "2.5 What is uv?",
    "text": "2.5 What is uv?\nuv is a new-generation Python package installer and resolver written in Rust. It offers several advantages over traditional tools like pip:\n\nExtremely fast package installation and dependency resolution\nBuilt-in virtual environment management\nCompatible with pip’s interface and package formats\nReliable dependency resolution\nOptimized for modern Python development\n\nHere, we will only be focusing on the installation and minimal validation of the uv that is required for the project.\nIf you want to know more about uv, you can visit the official website here\n\n2.5.1 Installation\n\n2.5.1.1 Installation Methods\n\nUnix/macOS\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nWindows (PowerShell)\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\nNote: After installation on Windows, you may need to add uv to your PATH. The installation location is %USERPROFILE%\\.local\\bin. You can add this to your PATH by:\n\nPress Windows + X and select “System”\nClick “Advanced system settings”\nClick “Environment Variables”\nUnder “User variables”, find and select “Path”\nClick “Edit”\nClick “New”\nAdd %USERPROFILE%\\.local\\bin\nClick “OK” on all windows\n\nYou can verify the installation by opening a new terminal or PowerShell window and running:\nuv --version\n\n\n\n2.5.2 Verifying Installation\nuv --version",
    "crumbs": [
      "Inital setting and Introduction",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#understanding-project-structure",
    "href": "chapters/01-initial-setting-and-tutorial.html#understanding-project-structure",
    "title": "1  Initial Setting and Tutorial",
    "section": "2.1 Understanding Project Structure",
    "text": "2.1 Understanding Project Structure\nBefore we dive into creating a new project, it’s important to understand what makes up a well-structured Python project:\n\nSource code directory (your main package)\nTests directory\nDocumentation\nBuild configuration files\nDevelopment tools configuration\nCI/CD configuration\nLicense and README files",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#using-cookiecutter",
    "href": "chapters/01-initial-setting-and-tutorial.html#using-cookiecutter",
    "title": "1  Initial Setting and Tutorial",
    "section": "2.2 Using Cookiecutter",
    "text": "2.2 Using Cookiecutter\n\n2.2.1 What is Cookiecutter?\nCookiecutter is a project template tool that we’ll use through uvx to create our project structure. It uses a templating engine to replace project variables with your custom values, ensuring consistent project structure across all your repositories.\n\n\n2.2.2 Project Template Selection\nWe’ll use the cookiecutter-uv template created by Florian Maas, which is specifically designed for modern Python projects using uv. This well-maintained template includes:\n\nModern dependency management with uv\nComprehensive testing setup with pytest\nDocumentation with MkDocs\nCode quality tools (ruff, mypy)\nCI/CD with GitHub Actions\nDocker support\nDev container configuration for VSCode\n\n\n\n2.2.3 Creating Your Project\nRun the template generator:\nuvx cookiecutter https://github.com/fpgmaas/cookiecutter-uv.git\nOnce you run the command, you will be prompted to enter some information about your project. This information will be used to generate the project structure and files.\nInstalled 22 packages in 11ms\n  [1/14] author (Florian Maas): Ameyanagi\n  [2/14] email (fpgmaas@gmail.com): contact@ameyanagi.com\n  [3/14] author_github_handle (fpgmaas): Ameyanagi\n  [4/14] project_name (example-project): StructuredPy-code\n  [5/14] project_slug (structuredpy_code):\n  [6/14] project_description (This is a template repository for Python projects that use uv for their dependency management.): This is a repository containing the example project used in the StructuredPy\n  [7/14] Select include_github_actions\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [8/14] Select publish_to_pypi\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [9/14] Select deptry\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [10/14] Select mkdocs\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [11/14] Select codecov\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [12/14] Select dockerfile\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [13/14] Select devcontainer\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [14/14] Select open_source_license\n    1 - MIT license\n    2 - BSD license\n    3 - ISC license\n    4 - Apache Software License 2.0\n    5 - GNU General Public License v3\n    6 - Not open source\n    Choose from [1/2/3/4/5/6] (1):\n\n\n2.2.4 Project directory\nYou can check the initial directory tree by running the following command:\ntree -a -L 4 StructuredPy-code # Please change the directory name to your project name or a directory name you specified in the cookiecutter command\nThe output will be like this:\nStructuredPy-code\n├── codecov.yaml\n├── CONTRIBUTING.md\n├── .devcontainer\n│   ├── devcontainer.json\n│   └── postCreateCommand.sh\n├── Dockerfile\n├── docs\n│   ├── index.md\n│   └── modules.md\n├── .editorconfig\n├── .github\n│   ├── actions\n│   │   └── setup-python-env\n│   │       └── action.yml\n│   └── workflows\n│       ├── main.yml\n│       ├── on-release-main.yml\n│       └── validate-codecov-config.yml\n├── .gitignore\n├── LICENSE\n├── Makefile\n├── mkdocs.yml\n├── .pre-commit-config.yaml\n├── pyproject.toml\n├── README.md\n├── structuredpy_code\n│   ├── foo.py\n│   └── __init__.py\n├── tests\n│   └── test_foo.py\n└── tox.ini\n\n9 directories, 23 files\n\n\n2.2.5 Initializing git repository\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/Ameyanagi/StructuredPy-code.git\ngit push -u origin main\n\n\n2.2.6 Installing the python dependencies\nmake install\nThis will run the following command:\nuv sync\nuv run pre-commit install\nThe output will be like this:\n🚀 Creating virtual environment using uv\nUsing CPython 3.13.1 interpreter at: /usr/bin/python3\nCreating virtual environment at: .venv\nResolved 63 packages in 620ms\n   Built structuredpy-code @ file:///home/ameyanagi/StructuredPy-code\nPrepared 59 packages in 1.12s\nInstalled 59 packages in 169ms\n + babel==2.16.0\n + cachetools==5.5.0\n + certifi==2024.12.14\n + cfgv==3.4.0\n + chardet==5.2.0\n + charset-normalizer==3.4.1\n + click==8.1.8\n + colorama==0.4.6\n + coverage==7.6.10\n + deptry==0.21.2\n + distlib==0.3.9\n + filelock==3.16.1\n + ghp-import==2.1.0\n + griffe==1.5.4\n + identify==2.6.5\n + idna==3.10\n + iniconfig==2.0.0\n + jinja2==3.1.5\n + markdown==3.7\n + markupsafe==3.0.2\n + mergedeep==1.3.4\n + mkdocs==1.6.1\n + mkdocs-autorefs==1.2.0\n + mkdocs-get-deps==0.2.0\n + mkdocs-material==9.5.49\n + mkdocs-material-extensions==1.3.1\n + mkdocstrings==0.27.0\n + mkdocstrings-python==1.13.0\n + mypy==1.14.1\n + mypy-extensions==1.0.0\n + nodeenv==1.9.1\n + packaging==24.2\n + paginate==0.5.7\n + pathspec==0.12.1\n + platformdirs==4.3.6\n + pluggy==1.5.0\n + pre-commit==4.0.1\n + pygments==2.19.1\n + pymdown-extensions==10.13\n + pyproject-api==1.8.0\n + pytest==8.3.4\n + pytest-cov==6.0.0\n + python-dateutil==2.9.0.post0\n + pyyaml==6.0.2\n + pyyaml-env-tag==0.1\n + regex==2024.11.6\n + requests==2.32.3\n + requirements-parser==0.11.0\n + ruff==0.8.6\n + six==1.17.0\n + structuredpy-code==0.0.1 (from file:///home/ameyanagi/StructuredPy-code)\n + tox==4.23.2\n + tox-uv==1.17.0\n + types-setuptools==75.6.0.20241223\n + typing-extensions==4.12.2\n + urllib3==2.3.0\n + uv==0.5.15\n + virtualenv==20.28.1\n + watchdog==6.0.0\npre-commit installed at .git/hooks/pre-commit",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/01-initial-setting-and-tutorial.html#github-setup-optional",
    "href": "chapters/01-initial-setting-and-tutorial.html#github-setup-optional",
    "title": "1  Initial Setting and Tutorial",
    "section": "1.3 GitHub Setup (Optional)",
    "text": "1.3 GitHub Setup (Optional)\nGitHub is a popular platform for hosting Git repositories and collaborating on code. You can use it to store your code, track changes, and work with others on projects. You can also use GitHub Actions for continuous integration and deployment (CI/CD) workflows.\nYou will need to create an account on GitHub and set up a personal access token to push code to GitHub.\n\n1.3.1 Creating a GitHub Account\n\nGo to github.com and sign up for an account\nVerify your email address\nSet up two-factor authentication (recommended)\n\n\n\n1.3.2 Creating a Personal Access Token\nModern GitHub security requires using tokens instead of passwords:\n\nGo to GitHub Settings → Developer settings → Personal access tokens → Tokens (classic)\nClick “Generate new token (classic)”\nSelect scopes:\n\nrepo (Full control of private repositories)\nworkflow (if using GitHub Actions)\nread:org (if working with organization repositories)\n\nSet an expiration date\nGenerate and copy the token immediately (it won’t be shown again)\n\nStore your token securely - you’ll need it when pushing to GitHub.",
    "crumbs": [
      "Inital setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html",
    "href": "chapters/0101-initial-setting-and-tutorial.html",
    "title": "1  Initial Setting and Tutorial",
    "section": "",
    "text": "1.1 Prerequisites\nThis tutorial will guide you through setting up a modern Python development environment with best practices for:\nBy following this guide, you’ll create a well-structured Python project that follows some of the best practices that people use for python. The setup includes automatic testing, documentation generation, and code quality checks - essential tools for professional Python development.\nBefore starting this tutorial, you should have:\nBut if you don’t have any of these, don’t worry! You can refer to the Appendix for more information.",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#prerequisites",
    "href": "chapters/0101-initial-setting-and-tutorial.html#prerequisites",
    "title": "1  Initial Setting and Tutorial",
    "section": "",
    "text": "Basic Python knowledge\nA GitHub account\nA text editor or IDE of your choice\nTerminal/command line familiarity",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#setting-up-git",
    "href": "chapters/0101-initial-setting-and-tutorial.html#setting-up-git",
    "title": "1  Initial Setting and Tutorial",
    "section": "1.2 Setting up Git",
    "text": "1.2 Setting up Git\n\n1.2.1 Initial Setup\n\n1.2.1.1 Installing Git\nBefore you can use Git, you need to install it on your system:\n\nWindows: Download and install from git-scm.com\nmacOS: Install via Homebrew: brew install git\nLinux: Install via package manager:\n# Ubuntu/Debian\nsudo apt-get install git\n\n# Fedora\nsudo dnf install git\n\n\n\n\n1.2.2 Configuring Git\nAfter installation, configure your identity: This will be required when you are pushing the code to the GitHub.\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"you@example.com\"\nAdditional recommended configurations: Whenever you are pushing to the GitHub, you will be asked for the username and password. To avoid this, you can store the credentials securely. If you are not using GitHub, then you can skip this step.\n# Store credentials securely\ngit config --global credential.helper store",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#github-setup-optional",
    "href": "chapters/0101-initial-setting-and-tutorial.html#github-setup-optional",
    "title": "1  Initial Setting and Tutorial",
    "section": "1.3 GitHub Setup (Optional)",
    "text": "1.3 GitHub Setup (Optional)\nGitHub is a popular platform for hosting Git repositories and collaborating on code. You can use it to store your code, track changes, and work with others on projects. You can also use GitHub Actions for continuous integration and deployment (CI/CD) workflows.\nYou will need to create an account on GitHub and set up a personal access token to push code to GitHub.\n\n1.3.1 Creating a GitHub Account\n\nGo to github.com and sign up for an account\nVerify your email address\nSet up two-factor authentication (recommended)\n\n\n\n1.3.2 Creating a Personal Access Token\nModern GitHub security requires using tokens instead of passwords:\n\nGo to GitHub Settings → Developer settings → Personal access tokens → Tokens (classic)\nClick “Generate new token (classic)”\nSelect scopes:\n\nrepo (Full control of private repositories)\nworkflow (if using GitHub Actions)\nread:org (if working with organization repositories)\n\nSet an expiration date\nGenerate and copy the token immediately (it won’t be shown again)\n\nStore your token securely - you’ll need it when pushing to GitHub.",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#uv-modern-python-package-management",
    "href": "chapters/0101-initial-setting-and-tutorial.html#uv-modern-python-package-management",
    "title": "1  Initial Setting and Tutorial",
    "section": "1.4 uv: Modern Python Package Management",
    "text": "1.4 uv: Modern Python Package Management\nuv is a new-generation Python package installer and resolver written in Rust. It offers several advantages over traditional tools like pip:\n\nExtremely fast package installation and dependency resolution\nBuilt-in virtual environment management\nCompatible with pip’s interface and package formats\nReliable dependency resolution\nOptimized for modern Python development\n\nHere, we will only be focusing on the installation and minimal validation of the uv that is required for the project.\nIf you want to know more about uv, you can visit the official website here\n\n1.4.1 Installation\n\n1.4.1.1 Installation Methods\n\nUnix/macOS\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nWindows (PowerShell)\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n\n\n\n\n\n\nNote\n\n\n\nNote: After installation on Windows, you may need to add uv to your PATH. The installation location is %USERPROFILE%\\.local\\bin. You can add this to your PATH by:\n\nPress Windows + X and select “System”\nClick “Advanced system settings”\nClick “Environment Variables”\nUnder “User variables”, find and select “Path”\nClick “Edit”\nClick “New”\nAdd %USERPROFILE%\\.local\\bin\nClick “OK” on all windows\n\n\n\n\n\n\n1.4.2 Verifying Installation\nYou can verify the installation by opening a new terminal or PowerShell window and running:\nuv --version",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#understanding-project-structure",
    "href": "chapters/0101-initial-setting-and-tutorial.html#understanding-project-structure",
    "title": "1  Initial Setting and Tutorial",
    "section": "2.1 Understanding Project Structure",
    "text": "2.1 Understanding Project Structure\nBefore we dive into creating a new project, it’s important to understand what makes up a well-structured Python project:\n\nSource code directory (your main package)\nTests directory\nDocumentation\nBuild configuration files\nDevelopment tools configuration\nCI/CD configuration\nLicense and README files",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#using-cookiecutter",
    "href": "chapters/0101-initial-setting-and-tutorial.html#using-cookiecutter",
    "title": "1  Initial Setting and Tutorial",
    "section": "2.2 Using Cookiecutter",
    "text": "2.2 Using Cookiecutter\n\n2.2.1 What is Cookiecutter?\nCookiecutter is a project template tool that we’ll use through uvx to create our project structure. It uses a templating engine to replace project variables with your custom values, ensuring consistent project structure across all your repositories.\n\n\n2.2.2 Project Template Selection\nWe’ll use the cookiecutter-uv template created by Florian Maas, which is specifically designed for modern Python projects using uv. This well-maintained template includes:\n\nModern dependency management with uv\nComprehensive testing setup with pytest\nDocumentation with MkDocs\nCode quality tools (ruff, mypy)\nCI/CD with GitHub Actions\nDocker support\nDev container configuration for VSCode\n\n\n\n2.2.3 Creating Your Project\nRun the template generator:\nuvx cookiecutter https://github.com/fpgmaas/cookiecutter-uv.git\nOnce you run the command, you will be prompted to enter some information about your project. This information will be used to generate the project structure and files.\nInstalled 22 packages in 11ms\n  [1/14] author (Florian Maas): Ameyanagi\n  [2/14] email (fpgmaas@gmail.com): contact@ameyanagi.com\n  [3/14] author_github_handle (fpgmaas): Ameyanagi\n  [4/14] project_name (example-project): StructuredPy-code\n  [5/14] project_slug (structuredpy_code):\n  [6/14] project_description (This is a template repository for Python projects that use uv for their dependency management.): This is a repository containing the example project used in the StructuredPy\n  [7/14] Select include_github_actions\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [8/14] Select publish_to_pypi\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [9/14] Select deptry\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [10/14] Select mkdocs\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [11/14] Select codecov\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [12/14] Select dockerfile\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [13/14] Select devcontainer\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [14/14] Select open_source_license\n    1 - MIT license\n    2 - BSD license\n    3 - ISC license\n    4 - Apache Software License 2.0\n    5 - GNU General Public License v3\n    6 - Not open source\n    Choose from [1/2/3/4/5/6] (1):\n\n\n2.2.4 Project directory\nYou can check the initial directory tree by running the following command:\ntree -a -L 4 StructuredPy-code # Please change the directory name to your project name or a directory name you specified in the cookiecutter command\nThe output will be like this:\nStructuredPy-code\n├── codecov.yaml\n├── CONTRIBUTING.md\n├── .devcontainer\n│   ├── devcontainer.json\n│   └── postCreateCommand.sh\n├── Dockerfile\n├── docs\n│   ├── index.md\n│   └── modules.md\n├── .editorconfig\n├── .github\n│   ├── actions\n│   │   └── setup-python-env\n│   │       └── action.yml\n│   └── workflows\n│       ├── main.yml\n│       ├── on-release-main.yml\n│       └── validate-codecov-config.yml\n├── .gitignore\n├── LICENSE\n├── Makefile\n├── mkdocs.yml\n├── .pre-commit-config.yaml\n├── pyproject.toml\n├── README.md\n├── structuredpy_code\n│   ├── foo.py\n│   └── __init__.py\n├── tests\n│   └── test_foo.py\n└── tox.ini\n\n9 directories, 23 files\n\n\n2.2.5 Initializing git repository\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/Ameyanagi/StructuredPy-code.git\ngit push -u origin main\n\n\n2.2.6 Installing the python dependencies\nmake install\nThis will run the following command:\nuv sync\nuv run pre-commit install\nThe output will be like this:\n🚀 Creating virtual environment using uv\nUsing CPython 3.13.1 interpreter at: /usr/bin/python3\nCreating virtual environment at: .venv\nResolved 63 packages in 620ms\n   Built structuredpy-code @ file:///home/ameyanagi/StructuredPy-code\nPrepared 59 packages in 1.12s\nInstalled 59 packages in 169ms\n + babel==2.16.0\n + cachetools==5.5.0\n + certifi==2024.12.14\n + cfgv==3.4.0\n + chardet==5.2.0\n + charset-normalizer==3.4.1\n + click==8.1.8\n + colorama==0.4.6\n + coverage==7.6.10\n + deptry==0.21.2\n + distlib==0.3.9\n + filelock==3.16.1\n + ghp-import==2.1.0\n + griffe==1.5.4\n + identify==2.6.5\n + idna==3.10\n + iniconfig==2.0.0\n + jinja2==3.1.5\n + markdown==3.7\n + markupsafe==3.0.2\n + mergedeep==1.3.4\n + mkdocs==1.6.1\n + mkdocs-autorefs==1.2.0\n + mkdocs-get-deps==0.2.0\n + mkdocs-material==9.5.49\n + mkdocs-material-extensions==1.3.1\n + mkdocstrings==0.27.0\n + mkdocstrings-python==1.13.0\n + mypy==1.14.1\n + mypy-extensions==1.0.0\n + nodeenv==1.9.1\n + packaging==24.2\n + paginate==0.5.7\n + pathspec==0.12.1\n + platformdirs==4.3.6\n + pluggy==1.5.0\n + pre-commit==4.0.1\n + pygments==2.19.1\n + pymdown-extensions==10.13\n + pyproject-api==1.8.0\n + pytest==8.3.4\n + pytest-cov==6.0.0\n + python-dateutil==2.9.0.post0\n + pyyaml==6.0.2\n + pyyaml-env-tag==0.1\n + regex==2024.11.6\n + requests==2.32.3\n + requirements-parser==0.11.0\n + ruff==0.8.6\n + six==1.17.0\n + structuredpy-code==0.0.1 (from file:///home/ameyanagi/StructuredPy-code)\n + tox==4.23.2\n + tox-uv==1.17.0\n + types-setuptools==75.6.0.20241223\n + typing-extensions==4.12.2\n + urllib3==2.3.0\n + uv==0.5.15\n + virtualenv==20.28.1\n + watchdog==6.0.0\npre-commit installed at .git/hooks/pre-commit",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#editing-the-code",
    "href": "chapters/0101-initial-setting-and-tutorial.html#editing-the-code",
    "title": "1  Initial Setting and Tutorial",
    "section": "2.3 Editing the code",
    "text": "2.3 Editing the code\n\n2.3.1 Open code in XX\n\n\n2.3.2 Running the code\nThe source code is included in the structuredpy_code directory. By default the foo.py file is included in the directory. You can run the code by running the following command:\nuv run structuredpy_code/foo.py\nAt this moment, there will be no output, because the foo.py file is empty.\ndef foo(bar: str) -&gt; str:\n    \"\"\"Summary line.\n\n    Extended description of function.\n\n    Args:\n        bar: Description of input argument.\n\n    Returns:\n        Description of return value\n    \"\"\"\n\n    return bar\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    pass\nWe will be make a new file and work on that file, but configuration would be the same.\n\n\n2.3.3 Creating a python file and running it\nLet’s create a new file called hello.py in the structuredpy_code directory. In the hello.py file, we will write a simple function that prints “hello world” to the console.\ndef main():\n    print(\"hello world\")\n\n\nif __name__ == \"__main__\":\n    main()\nYou can run the code by running the following command:\nuv run structuredpy_code/hello.py\nThe output will be like this:\nhello world\n\n\n2.3.4 Test the code\nLet’s look at the test file in the tests directory. The test file is called test_foo.py and it tests the foo function in the foo.py file.\n```python\nfrom structuredpy_code.foo import foo\n\n\ndef test_foo():\n    assert foo(\"foo\") == \"foo\"\n\n2.3.4.1 Running the test\nYou can run the test by running the following command:\nmake test\nThis command will run the following command:\nuv run python -m pytest --cov --cov-config=pyproject.toml --cov-report=xml\nThe output will be like this:\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 1 item\n\ntests/test_foo.py .                                                                                                                                 [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 1 passed in 0.03s ====================================================================\nWhat this does is that it runs the test file cnd see if the code runs with out the error. In the test_foo.py file, we are testing the foo function in the foo.py file will return the same string that we passed to it. assert is a keyword that is used to check if the condition is true. If the condition is false, it will raise an AssertionError.\n\n\n2.3.4.2 Basics of Test Driven Development (TDD)\nTDD is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved so that the tests pass. The cycle is repeated until the software is complete.\nLet’s assume we want to add a new function called add in the foo.py file. We will first create a add function stub in the test_foo.py file.\ndef add(a, b):\n    pass\nThen in the test_foo.py file, we will write a test for the add function. Here, we will write 4 tests for the add function to check if the function works as expected.\nfrom structuredpy_code.foo import add\n\ndef test_add():\n    assert add(1, 2) == 3\n\ndef test_add_negative():\n    assert add(-1, -2) == -3\n\ndef test_add_zero():\n    assert add(0, 0) == 0\n\ndef test_add_float():\n    assert add(1.5, 2.5) == 4.0\nThen we will run the test by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .FFFF                                                                                                                             [100%]\n\n======================================================================== FAILURES =========================================================================\n________________________________________________________________________ test_add _________________________________________________________________________\n\n    def test_add():\n&gt;       assert add(1, 2) == 3\nE       assert None == 3\nE        +  where None = add(1, 2)\n\ntests/test_foo.py:9: AssertionError\n____________________________________________________________________ test_add_negative ____________________________________________________________________\n\n    def test_add_negative():\n&gt;       assert add(-1, -2) == -3\nE       assert None == -3\nE        +  where None = add(-1, -2)\n\ntests/test_foo.py:13: AssertionError\n______________________________________________________________________ test_add_zero ______________________________________________________________________\n\n    def test_add_zero():\n&gt;       assert add(0, 0) == 0\nE       assert None == 0\nE        +  where None = add(0, 0)\n\ntests/test_foo.py:17: AssertionError\n_____________________________________________________________________ test_add_float ______________________________________________________________________\n\n    def test_add_float():\n&gt;       assert add(1.5, 2.5) == 4.0\nE       assert None == 4.0\nE        +  where None = add(1.5, 2.5)\n\ntests/test_foo.py:21: AssertionError\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n================================================================= short test summary info =================================================================\nFAILED tests/test_foo.py::test_add - assert None == 3\nFAILED tests/test_foo.py::test_add_negative - assert None == -3\nFAILED tests/test_foo.py::test_add_zero - assert None == 0\nFAILED tests/test_foo.py::test_add_float - assert None == 4.0\n=============================================================== 4 failed, 1 passed in 0.09s ===============================================================\nmake: *** [Makefile:21: test] Error 1\nWe now see that all the tests have failed, because we have not implemented the add function yet. The main idea of TDD is to write the test first, then implement the function to make the test pass.\nLet’s implement the add function in the foo.py file to make the test pass.\ndef add(a, b):\n    return a + b\nThen run the test again by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .....                                                                                                                             [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 5 passed in 0.03s ====================================================================",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#docs",
    "href": "chapters/0101-initial-setting-and-tutorial.html#docs",
    "title": "1  Initial Setting and Tutorial",
    "section": "2.4 Docs",
    "text": "2.4 Docs\nDocumentation is a very important part of programming, but it is not always easy to write documentation. In this work flow we will be using the docstring to write the documentation for the code. We will be using the mkdocs to generate the documentation for the code.\nmake docs\nThis will run the following command:\nuv run mkdocs serve\nThe output will be like this:\nmake docs\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nINFO    -  Documentation built in 0.25 seconds\nINFO    -  [02:42:02] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO    -  [02:42:02] Serving on http://127.0.0.1:8000/StructuredPy-code/\nIn this case, the documentation will be available at http://127.0.0.1:8000/StructuredPy-code/ in your web browser. You can quickly see that the documentation of the foo function is available in module section of the documentation, but the add function is not available in the documentation. This is because the add function does not have a docstring.\nThe docstring is a string that is used to document the code. It is written in the first line of the function, class, or module. There are several formats for writing docstrings, but we will be using the Google style for writing docstrings.\nLet’s add a docstring to the add function in the foo.py file.\ndef add(a, b):\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nThen run the test again by running the following command:\nmake docs\nYou can check from the docs that the add function is now available in the documentation. We have to note that the type definition is not available in the documentation, because we have not added the type definition to the function. Let’s add the type definition to the add function in the foo.py file.\ndef add(a: number, b: int) -&gt; int:\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nNow we can see that the type definition is now available in the documentation. The type definition is not necessary for the code to run, but it is a good practice to add the type definition to the function in terms of readability and maintainability of the code.\n\n2.4.1 Commit the code to Git\nYou can commit the code to Git by running the following command:\ngit add .\ngit commit -m \"add add function\"\nThe output will be like this:\n[INFO] Initializing environment for https://github.com/pre-commit/pre-commit-hooks.\n[WARNING] repo `https://github.com/pre-commit/pre-commit-hooks` uses deprecated stage names (commit, push) which will be removed in a future version.  Hint: often `pre-commit autoupdate --repo https://github.com/pre-commit/pre-commit-hooks` will fix this.  if it does not -- consider reporting an issue to that repo.\n[INFO] Initializing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier:prettier@3.0.3.\n[INFO] Installing environment for https://github.com/pre-commit/pre-commit-hooks.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\ncheck for case conflicts.................................................Passed\ncheck for merge conflicts................................................Passed\ncheck toml...........................................(no files to check)Skipped\ncheck yaml...........................................(no files to check)Skipped\nfix end of files.........................................................Passed\ntrim trailing whitespace.................................................Passed\nruff.....................................................................Passed\nruff-format..............................................................Passed\nprettier.................................................................Passed\n[main 233db95] add add function\n 4 files changed, 1232 insertions(+), 1 deletion(-)\n create mode 100644 structuredpy_code/hello.py\n create mode 100644 uv.lock\nThere will be whole bunch of output, because there is a pre-commit hook that runs when you commit the code to Git. This is important to keep the code clean and consistent,\nThen if you want to push the code to GitHub, you can run the following command:\ngit push",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0102-workflow-project.html",
    "href": "chapters/0102-workflow-project.html",
    "title": "2  Project Initialization Guide",
    "section": "",
    "text": "2.1 Understanding Project Structure\nWe will be using boilerplate that includes modern dependency management with uv, comprehensive testing setup with pytest, documentation with MkDocs, code quality tools, CI/CD with GitHub Actions, Docker support, and dev container configuration for VSCode. This will give you a solid foundation for professional Python development without having to set up each component manually.\nBefore we dive into creating a new project, it’s important to understand what makes up a well-structured Python project:",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0102-workflow-project.html#understanding-project-structure",
    "href": "chapters/0102-workflow-project.html#understanding-project-structure",
    "title": "2  Project Initialization Guide",
    "section": "",
    "text": "Source code directory (your main package)\nTests directory\nDocumentation\nBuild configuration files\nDevelopment tools configuration\nCI/CD configuration\nLicense and README files",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0102-workflow-project.html#using-cookiecutter",
    "href": "chapters/0102-workflow-project.html#using-cookiecutter",
    "title": "2  Project Initialization Guide",
    "section": "2.2 Using Cookiecutter",
    "text": "2.2 Using Cookiecutter\n\n2.2.1 What is Cookiecutter?\nCookiecutter is a project template tool that we’ll use through uvx to create our project structure. It uses a templating engine to replace project variables with your custom values, ensuring consistent project structure across all your repositories.\n\n\n2.2.2 Project Template Selection\nWe’ll use the cookiecutter-uv template created by Florian Maas, which is specifically designed for modern Python projects using uv. This well-maintained template includes:\n\nModern dependency management with uv\nComprehensive testing setup with pytest\nDocumentation with MkDocs\nCode quality tools (ruff, mypy)\nCI/CD with GitHub Actions\nDocker support\nDev container configuration for VSCode\n\n\n\n2.2.3 Project Initialization Workflow\nHere’s a high-level overview of the project initialization workflow:\n\n\n\n\n\ngraph TB\n    Init[Project Initialization] --&gt; Cookie[Run Cookiecutter]\n    Cookie --&gt; Setup[Setup Project Structure]\n    Setup --&gt; Git[Initialize Git]\n    Git --&gt; Install[make install]\n    \n    Install --&gt; DevLoop[Development Loop]\n    \n    subgraph DevLoop[Development Loop]\n        direction TB\n        WriteTest[Write Test] --&gt; Test1[make test]\n        Test1 --&gt; Code[Write/Edit Code]\n        Code --&gt; Test2[make test]\n        \n        Test2 --&gt;|Fail| Code\n        Test2 --&gt;|Pass| Check[make check]\n        \n        Check --&gt; Docs[make docs]\n        Docs --&gt; CommitGroup\n        \n        subgraph CommitGroup[Git Commit Process]\n            direction LR\n            Commit[Git Commit]\n            PreCommit[Pre-commit Hooks:&lt;br/&gt;- Check Conflicts&lt;br/&gt;- Ruff Format&lt;br/&gt;- Ruff Lint&lt;br/&gt;- Prettier]\n        end\n        \n        CommitGroup --&gt; CI[GitHub Actions CI]\n        CI --&gt; Deploy[make publish]\n    end\n    \n    %% Manual steps\n    classDef manual fill:#f9d6d6,stroke:#d64545\n    class Code,Commit,Init,Cookie,WriteTest,Git manual\n    \n    %% Automated steps\n    classDef automated fill:#d4edda,stroke:#28a745\n    class Install,Check,Test1,Test2,Docs,Deploy,CI,PreCommit automated\n    \n    %% Subgraphs\n    classDef process fill:#e6f3ff,stroke:#0056b3\n    class CommitGroup process\n    \n    %% Container\n    style DevLoop fill:#f0f0f0,stroke:#333,stroke-width:2px\n\n\n\n\n\n\n\n\n2.2.4 Creating Your Project\nRun the template generator:\nuvx cookiecutter https://github.com/fpgmaas/cookiecutter-uv.git\nOnce you run the command, you will be prompted to enter some information about your project. This information will be used to generate the project structure and files.\nInstalled 22 packages in 11ms\n  [1/14] author (Florian Maas): Ameyanagi\n  [2/14] email (fpgmaas@gmail.com): contact@ameyanagi.com\n  [3/14] author_github_handle (fpgmaas): Ameyanagi\n  [4/14] project_name (example-project): StructuredPy-code\n  [5/14] project_slug (structuredpy_code):\n  [6/14] project_description (This is a template repository for Python projects that use uv for their dependency management.): This is a repository containing the example project used in the StructuredPy\n  [7/14] Select include_github_actions\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [8/14] Select publish_to_pypi\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [9/14] Select deptry\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [10/14] Select mkdocs\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [11/14] Select codecov\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [12/14] Select dockerfile\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [13/14] Select devcontainer\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [14/14] Select open_source_license\n    1 - MIT license\n    2 - BSD license\n    3 - ISC license\n    4 - Apache Software License 2.0\n    5 - GNU General Public License v3\n    6 - Not open source\n    Choose from [1/2/3/4/5/6] (1):\n\n\n2.2.5 Project directory\nYou can check the initial directory tree by running the following command:\ntree -a -L 4 StructuredPy-code # Please change the directory name to your project name or a directory name you specified in the cookiecutter command\nThe output will be like this:\nStructuredPy-code\n├── codecov.yaml\n├── CONTRIBUTING.md\n├── .devcontainer\n│   ├── devcontainer.json\n│   └── postCreateCommand.sh\n├── Dockerfile\n├── docs\n│   ├── index.md\n│   └── modules.md\n├── .editorconfig\n├── .github\n│   ├── actions\n│   │   └── setup-python-env\n│   │       └── action.yml\n│   └── workflows\n│       ├── main.yml\n│       ├── on-release-main.yml\n│       └── validate-codecov-config.yml\n├── .gitignore\n├── LICENSE\n├── Makefile\n├── mkdocs.yml\n├── .pre-commit-config.yaml\n├── pyproject.toml\n├── README.md\n├── structuredpy_code\n│   ├── foo.py\n│   └── __init__.py\n├── tests\n│   └── test_foo.py\n└── tox.ini\n\n9 directories, 23 files\n\n\n2.2.6 Initializing git repository\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/Ameyanagi/StructuredPy-code.git\ngit push -u origin main\n\n\n2.2.7 Installing the python dependencies\nmake install\nThis will run the following command:\nuv sync\nuv run pre-commit install\nThe output will be like this:\n🚀 Creating virtual environment using uv\nUsing CPython 3.13.1 interpreter at: /usr/bin/python3\nCreating virtual environment at: .venv\nResolved 63 packages in 620ms\n   Built structuredpy-code @ file:///home/ameyanagi/StructuredPy-code\nPrepared 59 packages in 1.12s\nInstalled 59 packages in 169ms\n + babel==2.16.0\n + cachetools==5.5.0\n + certifi==2024.12.14\n + cfgv==3.4.0\n + chardet==5.2.0\n + charset-normalizer==3.4.1\n + click==8.1.8\n + colorama==0.4.6\n + coverage==7.6.10\n + deptry==0.21.2\n + distlib==0.3.9\n + filelock==3.16.1\n + ghp-import==2.1.0\n + griffe==1.5.4\n + identify==2.6.5\n + idna==3.10\n + iniconfig==2.0.0\n + jinja2==3.1.5\n + markdown==3.7\n + markupsafe==3.0.2\n + mergedeep==1.3.4\n + mkdocs==1.6.1\n + mkdocs-autorefs==1.2.0\n + mkdocs-get-deps==0.2.0\n + mkdocs-material==9.5.49\n + mkdocs-material-extensions==1.3.1\n + mkdocstrings==0.27.0\n + mkdocstrings-python==1.13.0\n + mypy==1.14.1\n + mypy-extensions==1.0.0\n + nodeenv==1.9.1\n + packaging==24.2\n + paginate==0.5.7\n + pathspec==0.12.1\n + platformdirs==4.3.6\n + pluggy==1.5.0\n + pre-commit==4.0.1\n + pygments==2.19.1\n + pymdown-extensions==10.13\n + pyproject-api==1.8.0\n + pytest==8.3.4\n + pytest-cov==6.0.0\n + python-dateutil==2.9.0.post0\n + pyyaml==6.0.2\n + pyyaml-env-tag==0.1\n + regex==2024.11.6\n + requests==2.32.3\n + requirements-parser==0.11.0\n + ruff==0.8.6\n + six==1.17.0\n + structuredpy-code==0.0.1 (from file:///home/ameyanagi/StructuredPy-code)\n + tox==4.23.2\n + tox-uv==1.17.0\n + types-setuptools==75.6.0.20241223\n + typing-extensions==4.12.2\n + urllib3==2.3.0\n + uv==0.5.15\n + virtualenv==20.28.1\n + watchdog==6.0.0\npre-commit installed at .git/hooks/pre-commit",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0102-workflow-project.html#editing-the-code",
    "href": "chapters/0102-workflow-project.html#editing-the-code",
    "title": "2  Project Initialization Guide",
    "section": "2.3 Editing the code",
    "text": "2.3 Editing the code\n\n2.3.1 Open code in XX\n\n\n2.3.2 Running the code\nThe source code is included in the structuredpy_code directory. By default the foo.py file is included in the directory. You can run the code by running the following command:\nuv run structuredpy_code/foo.py\nAt this moment, there will be no output, because the foo.py file is empty.\ndef foo(bar: str) -&gt; str:\n    \"\"\"Summary line.\n\n    Extended description of function.\n\n    Args:\n        bar: Description of input argument.\n\n    Returns:\n        Description of return value\n    \"\"\"\n\n    return bar\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    pass\nWe will be make a new file and work on that file, but configuration would be the same.\n\n\n2.3.3 Creating a python file and running it\nLet’s create a new file called hello.py in the structuredpy_code directory. In the hello.py file, we will write a simple function that prints “hello world” to the console.\ndef main():\n    print(\"hello world\")\n\n\nif __name__ == \"__main__\":\n    main()\nYou can run the code by running the following command:\nuv run structuredpy_code/hello.py\nThe output will be like this:\nhello world\n\n\n2.3.4 Test the code\nLet’s look at the test file in the tests directory. The test file is called test_foo.py and it tests the foo function in the foo.py file.\n```python\nfrom structuredpy_code.foo import foo\n\n\ndef test_foo():\n    assert foo(\"foo\") == \"foo\"\n\n2.3.4.1 Running the test\nYou can run the test by running the following command:\nmake test\nThis command will run the following command:\nuv run python -m pytest --cov --cov-config=pyproject.toml --cov-report=xml\nThe output will be like this:\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 1 item\n\ntests/test_foo.py .                                                                                                                                 [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 1 passed in 0.03s ====================================================================\nWhat this does is that it runs the test file cnd see if the code runs with out the error. In the test_foo.py file, we are testing the foo function in the foo.py file will return the same string that we passed to it. assert is a keyword that is used to check if the condition is true. If the condition is false, it will raise an AssertionError.\n\n\n2.3.4.2 Basics of Test Driven Development (TDD)\nTDD is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved so that the tests pass. The cycle is repeated until the software is complete.\nLet’s assume we want to add a new function called add in the foo.py file. We will first create a add function stub in the test_foo.py file.\ndef add(a, b):\n    pass\nThen in the test_foo.py file, we will write a test for the add function. Here, we will write 4 tests for the add function to check if the function works as expected.\nfrom structuredpy_code.foo import add\n\ndef test_add():\n    assert add(1, 2) == 3\n\ndef test_add_negative():\n    assert add(-1, -2) == -3\n\ndef test_add_zero():\n    assert add(0, 0) == 0\n\ndef test_add_float():\n    assert add(1.5, 2.5) == 4.0\nThen we will run the test by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .FFFF                                                                                                                             [100%]\n\n======================================================================== FAILURES =========================================================================\n________________________________________________________________________ test_add _________________________________________________________________________\n\n    def test_add():\n&gt;       assert add(1, 2) == 3\nE       assert None == 3\nE        +  where None = add(1, 2)\n\ntests/test_foo.py:9: AssertionError\n____________________________________________________________________ test_add_negative ____________________________________________________________________\n\n    def test_add_negative():\n&gt;       assert add(-1, -2) == -3\nE       assert None == -3\nE        +  where None = add(-1, -2)\n\ntests/test_foo.py:13: AssertionError\n______________________________________________________________________ test_add_zero ______________________________________________________________________\n\n    def test_add_zero():\n&gt;       assert add(0, 0) == 0\nE       assert None == 0\nE        +  where None = add(0, 0)\n\ntests/test_foo.py:17: AssertionError\n_____________________________________________________________________ test_add_float ______________________________________________________________________\n\n    def test_add_float():\n&gt;       assert add(1.5, 2.5) == 4.0\nE       assert None == 4.0\nE        +  where None = add(1.5, 2.5)\n\ntests/test_foo.py:21: AssertionError\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n================================================================= short test summary info =================================================================\nFAILED tests/test_foo.py::test_add - assert None == 3\nFAILED tests/test_foo.py::test_add_negative - assert None == -3\nFAILED tests/test_foo.py::test_add_zero - assert None == 0\nFAILED tests/test_foo.py::test_add_float - assert None == 4.0\n=============================================================== 4 failed, 1 passed in 0.09s ===============================================================\nmake: *** [Makefile:21: test] Error 1\nWe now see that all the tests have failed, because we have not implemented the add function yet. The main idea of TDD is to write the test first, then implement the function to make the test pass.\nLet’s implement the add function in the foo.py file to make the test pass.\ndef add(a, b):\n    return a + b\nThen run the test again by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .....                                                                                                                             [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 5 passed in 0.03s ====================================================================",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0102-workflow-project.html#docs",
    "href": "chapters/0102-workflow-project.html#docs",
    "title": "2  Project Initialization Guide",
    "section": "2.4 Docs",
    "text": "2.4 Docs\nDocumentation is a very important part of programming, but it is not always easy to write documentation. In this work flow we will be using the docstring to write the documentation for the code. We will be using the mkdocs to generate the documentation for the code.\nmake docs\nThis will run the following command:\nuv run mkdocs serve\nThe output will be like this:\nmake docs\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nINFO    -  Documentation built in 0.25 seconds\nINFO    -  [02:42:02] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO    -  [02:42:02] Serving on http://127.0.0.1:8000/StructuredPy-code/\nIn this case, the documentation will be available at http://127.0.0.1:8000/StructuredPy-code/ in your web browser. You can quickly see that the documentation of the foo function is available in module section of the documentation, but the add function is not available in the documentation. This is because the add function does not have a docstring.\nThe docstring is a string that is used to document the code. It is written in the first line of the function, class, or module. There are several formats for writing docstrings, but we will be using the Google style for writing docstrings.\nLet’s add a docstring to the add function in the foo.py file.\ndef add(a, b):\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nThen run the test again by running the following command:\nmake docs\nYou can check from the docs that the add function is now available in the documentation. We have to note that the type definition is not available in the documentation, because we have not added the type definition to the function. Let’s add the type definition to the add function in the foo.py file.\ndef add(a: number, b: int) -&gt; int:\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nNow we can see that the type definition is now available in the documentation. The type definition is not necessary for the code to run, but it is a good practice to add the type definition to the function in terms of readability and maintainability of the code.\n\n2.4.1 Commit the code to Git\nYou can commit the code to Git by running the following command:\ngit add .\ngit commit -m \"add add function\"\nThe output will be like this:\n[INFO] Initializing environment for https://github.com/pre-commit/pre-commit-hooks.\n[WARNING] repo `https://github.com/pre-commit/pre-commit-hooks` uses deprecated stage names (commit, push) which will be removed in a future version.  Hint: often `pre-commit autoupdate --repo https://github.com/pre-commit/pre-commit-hooks` will fix this.  if it does not -- consider reporting an issue to that repo.\n[INFO] Initializing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier:prettier@3.0.3.\n[INFO] Installing environment for https://github.com/pre-commit/pre-commit-hooks.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\ncheck for case conflicts.................................................Passed\ncheck for merge conflicts................................................Passed\ncheck toml...........................................(no files to check)Skipped\ncheck yaml...........................................(no files to check)Skipped\nfix end of files.........................................................Passed\ntrim trailing whitespace.................................................Passed\nruff.....................................................................Passed\nruff-format..............................................................Passed\nprettier.................................................................Passed\n[main 233db95] add add function\n 4 files changed, 1232 insertions(+), 1 deletion(-)\n create mode 100644 structuredpy_code/hello.py\n create mode 100644 uv.lock\nThere will be whole bunch of output, because there is a pre-commit hook that runs when you commit the code to Git. This is important to keep the code clean and consistent,\nThen if you want to push the code to GitHub, you can run the following command:\ngit push",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0101-initial-setting-and-tutorial.html#summary",
    "href": "chapters/0101-initial-setting-and-tutorial.html#summary",
    "title": "1  Initial Setting and Tutorial",
    "section": "1.5 Summary",
    "text": "1.5 Summary\nIn this tutorial, you learned how to set up a modern Python development environment with Git, GitHub, and uv. These tools will help you manage your code, collaborate with others, and install Python packages efficiently.\nIn the next chapter, we’ll create a new Python project using a cookiecutter template and set up a basic project structure.",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Initial Setting and Tutorial</span>"
    ]
  },
  {
    "objectID": "chapters/0102-project-initialization.html",
    "href": "chapters/0102-project-initialization.html",
    "title": "2  Project Initialization Guide",
    "section": "",
    "text": "2.1 Understanding Project Structure\nWe will be using boilerplate that includes modern dependency management with uv, comprehensive testing setup with pytest, documentation with MkDocs, code quality tools, CI/CD with GitHub Actions, Docker support, and dev container configuration for VSCode. This will give you a solid foundation for professional Python development without having to set up each component manually.\nBefore we dive into creating a new project, it’s important to understand what makes up a well-structured Python project:",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0102-project-initialization.html#understanding-project-structure",
    "href": "chapters/0102-project-initialization.html#understanding-project-structure",
    "title": "2  Project Initialization Guide",
    "section": "",
    "text": "Source code directory (your main package)\nTests directory\nDocumentation\nBuild configuration files\nDevelopment tools configuration\nCI/CD configuration\nLicense and README files",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0102-project-initialization.html#using-cookiecutter",
    "href": "chapters/0102-project-initialization.html#using-cookiecutter",
    "title": "2  Project Initialization Guide",
    "section": "2.2 Using Cookiecutter",
    "text": "2.2 Using Cookiecutter\n\n2.2.1 What is Cookiecutter?\nCookiecutter is a project template tool that we’ll use through uvx to create our project structure. It uses a templating engine to replace project variables with your custom values, ensuring consistent project structure across all your repositories.\n\n\n2.2.2 Project Template Selection\nWe’ll use the cookiecutter-uv template created by Florian Maas, which is specifically designed for modern Python projects using uv. This well-maintained template includes:\n\nModern dependency management with uv\nComprehensive testing setup with pytest\nDocumentation with MkDocs\nCode quality tools (ruff, mypy)\nCI/CD with GitHub Actions\nDocker support\nDev container configuration for VSCode\n\n\n\n2.2.3 Project Initialization Workflow\nHere’s a high-level overview of the project initialization workflow: The green boxes represent automated steps, while the red boxes represent manual steps.\n\n\n\n\n\ngraph TB\n    Init[Project Initialization] --&gt; Cookie[Run Cookiecutter]\n    Cookie --&gt; Setup[Setup Project Structure]\n    Setup --&gt; Git[Initialize Git]\n    Git --&gt; Install[make install]\n    \n    Install --&gt; DevLoop[Development Loop]\n    \n    subgraph DevLoop[Development Loop]\n        direction TB\n        WriteTest[Write Test] --&gt; Test1[make test]\n        Test1 --&gt; Code[Write/Edit Code]\n        Code --&gt; Test2[make test]\n        \n        Test2 --&gt;|Fail| Code\n        Test2 --&gt;|Pass| Check[make check]\n        \n        Check --&gt; Docs[make docs]\n        Docs --&gt; CommitGroup\n        \n        subgraph CommitGroup[Git Commit Process]\n            direction LR\n            Commit[Git Commit]\n            PreCommit[Pre-commit Hooks:&lt;br/&gt;- Check Conflicts&lt;br/&gt;- Ruff Format&lt;br/&gt;- Ruff Lint&lt;br/&gt;- Prettier]\n        end\n        \n        CommitGroup --&gt; CI[GitHub Actions CI]\n        CI --&gt; Deploy[make publish]\n    end\n    \n    %% Manual steps\n    classDef manual fill:#f9d6d6,stroke:#d64545\n    class Code,Commit,Init,Cookie,WriteTest,Git manual\n    \n    %% Automated steps\n    classDef automated fill:#d4edda,stroke:#28a745\n    class Install,Check,Test1,Test2,Docs,Deploy,CI,PreCommit automated\n    \n    %% Subgraphs\n    classDef process fill:#e6f3ff,stroke:#0056b3\n    class CommitGroup process\n    \n    %% Container\n    style DevLoop fill:#f0f0f0,stroke:#333,stroke-width:2px\n\n\n\n\n\n\n\n\n2.2.4 Creating Your Project\nRun the template generator:\nuvx cookiecutter https://github.com/fpgmaas/cookiecutter-uv.git\nOnce you run the command, you will be prompted to enter some information about your project. This information will be used to generate the project structure and files.\nInstalled 22 packages in 11ms\n  [1/14] author (Florian Maas): Ameyanagi\n  [2/14] email (fpgmaas@gmail.com): contact@ameyanagi.com\n  [3/14] author_github_handle (fpgmaas): Ameyanagi\n  [4/14] project_name (example-project): StructuredPy-code\n  [5/14] project_slug (structuredpy_code):\n  [6/14] project_description (This is a template repository for Python projects that use uv for their dependency management.): This is a repository containing the example project used in the StructuredPy\n  [7/14] Select include_github_actions\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [8/14] Select publish_to_pypi\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [9/14] Select deptry\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [10/14] Select mkdocs\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [11/14] Select codecov\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [12/14] Select dockerfile\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [13/14] Select devcontainer\n    1 - y\n    2 - n\n    Choose from [1/2] (1):\n  [14/14] Select open_source_license\n    1 - MIT license\n    2 - BSD license\n    3 - ISC license\n    4 - Apache Software License 2.0\n    5 - GNU General Public License v3\n    6 - Not open source\n    Choose from [1/2/3/4/5/6] (1):\n\n\n2.2.5 Project directory\nYou can check the initial directory tree by running the following command:\ntree -a -L 4 StructuredPy-code # Please change the directory name to your project name or a directory name you specified in the cookiecutter command\nThe output will be like this:\nStructuredPy-code\n├── codecov.yaml\n├── CONTRIBUTING.md\n├── .devcontainer\n│   ├── devcontainer.json\n│   └── postCreateCommand.sh\n├── Dockerfile\n├── docs\n│   ├── index.md\n│   └── modules.md\n├── .editorconfig\n├── .github\n│   ├── actions\n│   │   └── setup-python-env\n│   │       └── action.yml\n│   └── workflows\n│       ├── main.yml\n│       ├── on-release-main.yml\n│       └── validate-codecov-config.yml\n├── .gitignore\n├── LICENSE\n├── Makefile\n├── mkdocs.yml\n├── .pre-commit-config.yaml\n├── pyproject.toml\n├── README.md\n├── structuredpy_code\n│   ├── foo.py\n│   └── __init__.py\n├── tests\n│   └── test_foo.py\n└── tox.ini\n\n9 directories, 23 files\n\n\n2.2.6 Initializing git repository\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/Ameyanagi/StructuredPy-code.git\ngit push -u origin main\n\n\n2.2.7 Installing the python dependencies\nmake install\nThis will run the following command:\nuv sync\nuv run pre-commit install\nThe output will be like this:\n🚀 Creating virtual environment using uv\nUsing CPython 3.13.1 interpreter at: /usr/bin/python3\nCreating virtual environment at: .venv\nResolved 63 packages in 620ms\n   Built structuredpy-code @ file:///home/ameyanagi/StructuredPy-code\nPrepared 59 packages in 1.12s\nInstalled 59 packages in 169ms\n + babel==2.16.0\n + cachetools==5.5.0\n + certifi==2024.12.14\n + cfgv==3.4.0\n + chardet==5.2.0\n + charset-normalizer==3.4.1\n + click==8.1.8\n + colorama==0.4.6\n + coverage==7.6.10\n + deptry==0.21.2\n + distlib==0.3.9\n + filelock==3.16.1\n + ghp-import==2.1.0\n + griffe==1.5.4\n + identify==2.6.5\n + idna==3.10\n + iniconfig==2.0.0\n + jinja2==3.1.5\n + markdown==3.7\n + markupsafe==3.0.2\n + mergedeep==1.3.4\n + mkdocs==1.6.1\n + mkdocs-autorefs==1.2.0\n + mkdocs-get-deps==0.2.0\n + mkdocs-material==9.5.49\n + mkdocs-material-extensions==1.3.1\n + mkdocstrings==0.27.0\n + mkdocstrings-python==1.13.0\n + mypy==1.14.1\n + mypy-extensions==1.0.0\n + nodeenv==1.9.1\n + packaging==24.2\n + paginate==0.5.7\n + pathspec==0.12.1\n + platformdirs==4.3.6\n + pluggy==1.5.0\n + pre-commit==4.0.1\n + pygments==2.19.1\n + pymdown-extensions==10.13\n + pyproject-api==1.8.0\n + pytest==8.3.4\n + pytest-cov==6.0.0\n + python-dateutil==2.9.0.post0\n + pyyaml==6.0.2\n + pyyaml-env-tag==0.1\n + regex==2024.11.6\n + requests==2.32.3\n + requirements-parser==0.11.0\n + ruff==0.8.6\n + six==1.17.0\n + structuredpy-code==0.0.1 (from file:///home/ameyanagi/StructuredPy-code)\n + tox==4.23.2\n + tox-uv==1.17.0\n + types-setuptools==75.6.0.20241223\n + typing-extensions==4.12.2\n + urllib3==2.3.0\n + uv==0.5.15\n + virtualenv==20.28.1\n + watchdog==6.0.0\npre-commit installed at .git/hooks/pre-commit",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0102-project-initialization.html#editing-the-code",
    "href": "chapters/0102-project-initialization.html#editing-the-code",
    "title": "2  Project Initialization Guide",
    "section": "2.3 Editing the code",
    "text": "2.3 Editing the code\n\n2.3.1 Open code in XX\n\n\n2.3.2 Running the code\nThe source code is included in the structuredpy_code directory. By default the foo.py file is included in the directory. You can run the code by running the following command:\nuv run structuredpy_code/foo.py\nAt this moment, there will be no output, because the foo.py file is empty.\ndef foo(bar: str) -&gt; str:\n    \"\"\"Summary line.\n\n    Extended description of function.\n\n    Args:\n        bar: Description of input argument.\n\n    Returns:\n        Description of return value\n    \"\"\"\n\n    return bar\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    pass\nWe will be make a new file and work on that file, but configuration would be the same.\n\n\n2.3.3 Creating a python file and running it\nLet’s create a new file called hello.py in the structuredpy_code directory. In the hello.py file, we will write a simple function that prints “hello world” to the console.\ndef main():\n    print(\"hello world\")\n\n\nif __name__ == \"__main__\":\n    main()\nYou can run the code by running the following command:\nuv run structuredpy_code/hello.py\nThe output will be like this:\nhello world\n\n\n2.3.4 Test the code\nLet’s look at the test file in the tests directory. The test file is called test_foo.py and it tests the foo function in the foo.py file.\n```python\nfrom structuredpy_code.foo import foo\n\n\ndef test_foo():\n    assert foo(\"foo\") == \"foo\"\n\n2.3.4.1 Running the test\nYou can run the test by running the following command:\nmake test\nThis command will run the following command:\nuv run python -m pytest --cov --cov-config=pyproject.toml --cov-report=xml\nThe output will be like this:\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 1 item\n\ntests/test_foo.py .                                                                                                                                 [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 1 passed in 0.03s ====================================================================\nWhat this does is that it runs the test file cnd see if the code runs with out the error. In the test_foo.py file, we are testing the foo function in the foo.py file will return the same string that we passed to it. assert is a keyword that is used to check if the condition is true. If the condition is false, it will raise an AssertionError.\n\n\n2.3.4.2 Basics of Test Driven Development (TDD)\nTDD is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved so that the tests pass. The cycle is repeated until the software is complete.\nLet’s assume we want to add a new function called add in the foo.py file. We will first create a add function stub in the test_foo.py file.\ndef add(a, b):\n    pass\nThen in the test_foo.py file, we will write a test for the add function. Here, we will write 4 tests for the add function to check if the function works as expected.\nfrom structuredpy_code.foo import add\n\ndef test_add():\n    assert add(1, 2) == 3\n\ndef test_add_negative():\n    assert add(-1, -2) == -3\n\ndef test_add_zero():\n    assert add(0, 0) == 0\n\ndef test_add_float():\n    assert add(1.5, 2.5) == 4.0\nThen we will run the test by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .FFFF                                                                                                                             [100%]\n\n======================================================================== FAILURES =========================================================================\n________________________________________________________________________ test_add _________________________________________________________________________\n\n    def test_add():\n&gt;       assert add(1, 2) == 3\nE       assert None == 3\nE        +  where None = add(1, 2)\n\ntests/test_foo.py:9: AssertionError\n____________________________________________________________________ test_add_negative ____________________________________________________________________\n\n    def test_add_negative():\n&gt;       assert add(-1, -2) == -3\nE       assert None == -3\nE        +  where None = add(-1, -2)\n\ntests/test_foo.py:13: AssertionError\n______________________________________________________________________ test_add_zero ______________________________________________________________________\n\n    def test_add_zero():\n&gt;       assert add(0, 0) == 0\nE       assert None == 0\nE        +  where None = add(0, 0)\n\ntests/test_foo.py:17: AssertionError\n_____________________________________________________________________ test_add_float ______________________________________________________________________\n\n    def test_add_float():\n&gt;       assert add(1.5, 2.5) == 4.0\nE       assert None == 4.0\nE        +  where None = add(1.5, 2.5)\n\ntests/test_foo.py:21: AssertionError\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n================================================================= short test summary info =================================================================\nFAILED tests/test_foo.py::test_add - assert None == 3\nFAILED tests/test_foo.py::test_add_negative - assert None == -3\nFAILED tests/test_foo.py::test_add_zero - assert None == 0\nFAILED tests/test_foo.py::test_add_float - assert None == 4.0\n=============================================================== 4 failed, 1 passed in 0.09s ===============================================================\nmake: *** [Makefile:21: test] Error 1\nWe now see that all the tests have failed, because we have not implemented the add function yet. The main idea of TDD is to write the test first, then implement the function to make the test pass.\nLet’s implement the add function in the foo.py file to make the test pass.\ndef add(a, b):\n    return a + b\nThen run the test again by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .....                                                                                                                             [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 5 passed in 0.03s ====================================================================",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0102-project-initialization.html#docs",
    "href": "chapters/0102-project-initialization.html#docs",
    "title": "2  Project Initialization Guide",
    "section": "2.4 Docs",
    "text": "2.4 Docs\nDocumentation is a very important part of programming, but it is not always easy to write documentation. In this work flow we will be using the docstring to write the documentation for the code. We will be using the mkdocs to generate the documentation for the code.\nmake docs\nThis will run the following command:\nuv run mkdocs serve\nThe output will be like this:\nmake docs\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nINFO    -  Documentation built in 0.25 seconds\nINFO    -  [02:42:02] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO    -  [02:42:02] Serving on http://127.0.0.1:8000/StructuredPy-code/\nIn this case, the documentation will be available at http://127.0.0.1:8000/StructuredPy-code/ in your web browser. You can quickly see that the documentation of the foo function is available in module section of the documentation, but the add function is not available in the documentation. This is because the add function does not have a docstring.\nThe docstring is a string that is used to document the code. It is written in the first line of the function, class, or module. There are several formats for writing docstrings, but we will be using the Google style for writing docstrings.\nLet’s add a docstring to the add function in the foo.py file.\ndef add(a, b):\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nThen run the test again by running the following command:\nmake docs\nYou can check from the docs that the add function is now available in the documentation. We have to note that the type definition is not available in the documentation, because we have not added the type definition to the function. Let’s add the type definition to the add function in the foo.py file.\ndef add(a: number, b: int) -&gt; int:\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nNow we can see that the type definition is now available in the documentation. The type definition is not necessary for the code to run, but it is a good practice to add the type definition to the function in terms of readability and maintainability of the code.\n\n2.4.1 Commit the code to Git\nYou can commit the code to Git by running the following command:\ngit add .\ngit commit -m \"add add function\"\nThe output will be like this:\n[INFO] Initializing environment for https://github.com/pre-commit/pre-commit-hooks.\n[WARNING] repo `https://github.com/pre-commit/pre-commit-hooks` uses deprecated stage names (commit, push) which will be removed in a future version.  Hint: often `pre-commit autoupdate --repo https://github.com/pre-commit/pre-commit-hooks` will fix this.  if it does not -- consider reporting an issue to that repo.\n[INFO] Initializing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier:prettier@3.0.3.\n[INFO] Installing environment for https://github.com/pre-commit/pre-commit-hooks.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\ncheck for case conflicts.................................................Passed\ncheck for merge conflicts................................................Passed\ncheck toml...........................................(no files to check)Skipped\ncheck yaml...........................................(no files to check)Skipped\nfix end of files.........................................................Passed\ntrim trailing whitespace.................................................Passed\nruff.....................................................................Passed\nruff-format..............................................................Passed\nprettier.................................................................Passed\n[main 233db95] add add function\n 4 files changed, 1232 insertions(+), 1 deletion(-)\n create mode 100644 structuredpy_code/hello.py\n create mode 100644 uv.lock\nThere will be whole bunch of output, because there is a pre-commit hook that runs when you commit the code to Git. This is important to keep the code clean and consistent,\nThen if you want to push the code to GitHub, you can run the following command:\ngit push",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Project Initialization Guide</span>"
    ]
  },
  {
    "objectID": "chapters/0103-workflow.html",
    "href": "chapters/0103-workflow.html",
    "title": "3  General workflow of coding",
    "section": "",
    "text": "3.1 Open code in Editor\nVscode:\nNeovim:",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>General workflow of coding</span>"
    ]
  },
  {
    "objectID": "chapters/0103-workflow.html#running-the-code",
    "href": "chapters/0103-workflow.html#running-the-code",
    "title": "3  General workflow of coding",
    "section": "3.2 Running the code",
    "text": "3.2 Running the code\nThe source code is included in the structuredpy_code directory. By default the foo.py file is included in the directory. You can run the code by running the following command:\nuv run structuredpy_code/foo.py\nAt this moment, there will be no output, because the foo.py file is empty.\ndef foo(bar: str) -&gt; str:\n    \"\"\"Summary line.\n\n    Extended description of function.\n\n    Args:\n        bar: Description of input argument.\n\n    Returns:\n        Description of return value\n    \"\"\"\n\n    return bar\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    pass\nWe will be make a new file and work on that file, but configuration would be the same.",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>General workflow of coding</span>"
    ]
  },
  {
    "objectID": "chapters/0103-workflow.html#creating-a-python-file-and-running-it",
    "href": "chapters/0103-workflow.html#creating-a-python-file-and-running-it",
    "title": "3  General workflow of coding",
    "section": "3.3 Creating a python file and running it",
    "text": "3.3 Creating a python file and running it\nLet’s create a new file called hello.py in the structuredpy_code directory. In the hello.py file, we will write a simple function that prints “hello world” to the console.\ndef main():\n    print(\"hello world\")\n\n\nif __name__ == \"__main__\":\n    main()\nYou can run the code by running the following command:\nuv run structuredpy_code/hello.py\nThe output will be like this:\nhello world",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>General workflow of coding</span>"
    ]
  },
  {
    "objectID": "chapters/0103-workflow.html#test-the-code",
    "href": "chapters/0103-workflow.html#test-the-code",
    "title": "3  General workflow of coding",
    "section": "3.4 Test the code",
    "text": "3.4 Test the code\nLet’s look at the test file in the tests directory. The test file is called test_foo.py and it tests the foo function in the foo.py file.\n```python\nfrom structuredpy_code.foo import foo\n\n\ndef test_foo():\n    assert foo(\"foo\") == \"foo\"\n\n3.4.1 Running the test\nYou can run the test by running the following command:\nmake test\nThis command will run the following command:\nuv run python -m pytest --cov --cov-config=pyproject.toml --cov-report=xml\nThe output will be like this:\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 1 item\n\ntests/test_foo.py .                                                                                                                                 [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 1 passed in 0.03s ====================================================================\nWhat this does is that it runs the test file cnd see if the code runs with out the error. In the test_foo.py file, we are testing the foo function in the foo.py file will return the same string that we passed to it. assert is a keyword that is used to check if the condition is true. If the condition is false, it will raise an AssertionError.\n\n3.4.1.1 Basics of Test Driven Development (TDD)\nTDD is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved so that the tests pass. The cycle is repeated until the software is complete.\nLet’s assume we want to add a new function called add in the foo.py file. We will first create a add function stub in the test_foo.py file.\ndef add(a, b):\n    pass\nThen in the test_foo.py file, we will write a test for the add function. Here, we will write 4 tests for the add function to check if the function works as expected.\nfrom structuredpy_code.foo import add\n\ndef test_add():\n    assert add(1, 2) == 3\n\ndef test_add_negative():\n    assert add(-1, -2) == -3\n\ndef test_add_zero():\n    assert add(0, 0) == 0\n\ndef test_add_float():\n    assert add(1.5, 2.5) == 4.0\nThen we will run the test by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .FFFF                                                                                                                             [100%]\n\n======================================================================== FAILURES =========================================================================\n________________________________________________________________________ test_add _________________________________________________________________________\n\n    def test_add():\n&gt;       assert add(1, 2) == 3\nE       assert None == 3\nE        +  where None = add(1, 2)\n\ntests/test_foo.py:9: AssertionError\n____________________________________________________________________ test_add_negative ____________________________________________________________________\n\n    def test_add_negative():\n&gt;       assert add(-1, -2) == -3\nE       assert None == -3\nE        +  where None = add(-1, -2)\n\ntests/test_foo.py:13: AssertionError\n______________________________________________________________________ test_add_zero ______________________________________________________________________\n\n    def test_add_zero():\n&gt;       assert add(0, 0) == 0\nE       assert None == 0\nE        +  where None = add(0, 0)\n\ntests/test_foo.py:17: AssertionError\n_____________________________________________________________________ test_add_float ______________________________________________________________________\n\n    def test_add_float():\n&gt;       assert add(1.5, 2.5) == 4.0\nE       assert None == 4.0\nE        +  where None = add(1.5, 2.5)\n\ntests/test_foo.py:21: AssertionError\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n================================================================= short test summary info =================================================================\nFAILED tests/test_foo.py::test_add - assert None == 3\nFAILED tests/test_foo.py::test_add_negative - assert None == -3\nFAILED tests/test_foo.py::test_add_zero - assert None == 0\nFAILED tests/test_foo.py::test_add_float - assert None == 4.0\n=============================================================== 4 failed, 1 passed in 0.09s ===============================================================\nmake: *** [Makefile:21: test] Error 1\nWe now see that all the tests have failed, because we have not implemented the add function yet. The main idea of TDD is to write the test first, then implement the function to make the test pass.\nLet’s implement the add function in the foo.py file to make the test pass.\ndef add(a, b):\n    return a + b\nThen run the test again by running the following command:\nmake test\n🚀 Testing code: Running pytest\n=================================================================== test session starts ===================================================================\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/ameyanagi/StructuredPy-code\nconfigfile: pyproject.toml\ntestpaths: tests\nplugins: cov-6.0.0\ncollected 5 items\n\ntests/test_foo.py .....                                                                                                                             [100%]\n\n---------- coverage: platform linux, python 3.13.1-final-0 -----------\nCoverage XML written to file coverage.xml\n\n\n==================================================================== 5 passed in 0.03s ====================================================================",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>General workflow of coding</span>"
    ]
  },
  {
    "objectID": "chapters/0103-workflow.html#docs",
    "href": "chapters/0103-workflow.html#docs",
    "title": "3  General workflow of coding",
    "section": "3.5 Docs",
    "text": "3.5 Docs\nDocumentation is a very important part of programming, but it is not always easy to write documentation. In this work flow we will be using the docstring to write the documentation for the code. We will be using the mkdocs to generate the documentation for the code.\nmake docs\nThis will run the following command:\nuv run mkdocs serve\nThe output will be like this:\nmake docs\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nINFO    -  Documentation built in 0.25 seconds\nINFO    -  [02:42:02] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO    -  [02:42:02] Serving on http://127.0.0.1:8000/StructuredPy-code/\nIn this case, the documentation will be available at http://127.0.0.1:8000/StructuredPy-code/ in your web browser. You can quickly see that the documentation of the foo function is available in module section of the documentation, but the add function is not available in the documentation. This is because the add function does not have a docstring.\nThe docstring is a string that is used to document the code. It is written in the first line of the function, class, or module. There are several formats for writing docstrings, but we will be using the Google style for writing docstrings.\nLet’s add a docstring to the add function in the foo.py file.\ndef add(a, b):\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nThen run the test again by running the following command:\nmake docs\nYou can check from the docs that the add function is now available in the documentation. We have to note that the type definition is not available in the documentation, because we have not added the type definition to the function. Let’s add the type definition to the add function in the foo.py file.\ndef add(a: number, b: int) -&gt; int:\n    \"\"\"Add two numbers.\n\n    Args:\n        a: The first number.\n        b: The second number.\n\n    Returns:\n        The sum of the two numbers.\n    \"\"\"\n    return a + b\nNow we can see that the type definition is now available in the documentation. The type definition is not necessary for the code to run, but it is a good practice to add the type definition to the function in terms of readability and maintainability of the code.",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>General workflow of coding</span>"
    ]
  },
  {
    "objectID": "chapters/0103-workflow.html#commit-the-code-to-git",
    "href": "chapters/0103-workflow.html#commit-the-code-to-git",
    "title": "3  General workflow of coding",
    "section": "3.6 Commit the code to Git",
    "text": "3.6 Commit the code to Git\nYou can commit the code to Git by running the following command:\ngit add .\ngit commit -m \"add add function\"\nThe output will be like this:\n[INFO] Initializing environment for https://github.com/pre-commit/pre-commit-hooks.\n[WARNING] repo `https://github.com/pre-commit/pre-commit-hooks` uses deprecated stage names (commit, push) which will be removed in a future version.  Hint: often `pre-commit autoupdate --repo https://github.com/pre-commit/pre-commit-hooks` will fix this.  if it does not -- consider reporting an issue to that repo.\n[INFO] Initializing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Initializing environment for https://github.com/pre-commit/mirrors-prettier:prettier@3.0.3.\n[INFO] Installing environment for https://github.com/pre-commit/pre-commit-hooks.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/astral-sh/ruff-pre-commit.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\n[INFO] Installing environment for https://github.com/pre-commit/mirrors-prettier.\n[INFO] Once installed this environment will be reused.\n[INFO] This may take a few minutes...\ncheck for case conflicts.................................................Passed\ncheck for merge conflicts................................................Passed\ncheck toml...........................................(no files to check)Skipped\ncheck yaml...........................................(no files to check)Skipped\nfix end of files.........................................................Passed\ntrim trailing whitespace.................................................Passed\nruff.....................................................................Passed\nruff-format..............................................................Passed\nprettier.................................................................Passed\n[main 233db95] add add function\n 4 files changed, 1232 insertions(+), 1 deletion(-)\n create mode 100644 structuredpy_code/hello.py\n create mode 100644 uv.lock\nThere will be whole bunch of output, because there is a pre-commit hook that runs when you commit the code to Git. This is important to keep the code clean and consistent,\nThen if you want to push the code to GitHub, you can run the following command:\ngit push",
    "crumbs": [
      "Initial setting and basic workflow",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>General workflow of coding</span>"
    ]
  }
]